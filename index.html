<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Language Shooter</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- Removed SortableJS CSS -->
    <style>
        /* Base Styles (Adapted from provided CSS) */
        :root {
            --primary: #1a73e8; /* Modern blue color (Google style) */
            --primary-hover: #0b5fdb; /* Darker shade for hover */
            --secondary: #e5e7eb;

            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --warning: #f59e0b; /* Yellow */
            --light: #f9fafb;

            /* target and shooter color */
            --accent: #8b5cf6; /* target color */
            --target-text-color: white; /* target text color */
            --dark: #111827; /* shooter color */
            --shooter-text-color: white; /* shooter text color */
            --success: #10b981; /* Green */
             --danger: #ef4444; /* Red */

            
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --radius: 0.5rem;
            --transition: all 0.3s ease;

            /* Font for targets/shooter */
             --word-box-font-family: KaiTi, 'Kaiti SC', DFKai-SB, BiauKai, 'Microsoft YaHei', 'SimHei', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
             --word-box-font-size: 1.6rem; /* Slightly larger for game elements */

            /* Game Speeds */
            --shooter-speed: 15px; /* Pixels moved per arrow key press */
            --bullet-speed: 15px; /* Pixels moved per frame */
            --target-downward-speed: 0.5px; /* Pixels moved down per frame */
            --target-horizontal-speed-max: 1.5px; /* Max absolute horizontal speed */
        }

        /* Rotating icon animation */
        .rotate-icon { display: inline-block; animation: spin 3s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Text fill effect */
        .fill-text { display: inline-block; background: linear-gradient(90deg, var(--primary), var(--accent)); background-size: 200% 100%; -webkit-background-clip: text; color: transparent; animation: fillText 5s ease infinite; }
        @keyframes fillText { from { background-position: -100% 0; } to { background-position: 0 0; } }

        /* Typography */
        body { font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; margin: 0; padding: 0; background-color: #f3f4f6; color: var(--text-primary); line-height: 1.5; }
        h1, h2, h3, h4, h5, h6 { font-weight: 600; margin-top: 0; color: var(--dark); }
        h1 { font-size: 2rem; margin-bottom: 1.5rem; }
        h2 { font-size: 1.5rem; margin-bottom: 1rem; }

        /* Layout */
        .app-container { max-width: 1000px; margin: 0 auto; padding: 1rem; min-height: 100vh; display: flex; flex-direction: column; }
        .app-header { text-align: center; padding: 1rem 0; border-bottom: 1px solid var(--secondary); margin-bottom: 2rem; }
        .app-footer { margin-top: auto; text-align: center; padding: 1rem 0; font-size: 0.875rem; color: var(--text-secondary); border-top: 1px solid var(--secondary); }
        .app-footer a { color: #6b7280; text-decoration: none; }

        /* Cards and Screens */
        .screen { display: none; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease; transform: translateY(10px); }
        .screen.active { display: block; opacity: 1; transform: translateY(0); }
        .card { background: white; border-radius: var(--radius); box-shadow: var(--shadow); padding: 2rem; margin-bottom: 1.5rem; transition: var(--transition); }
        .card-header { margin-bottom: 1.5rem; border-bottom: 1px solid var(--secondary); padding-bottom: 1rem; }
        .card-title { font-size: 1.25rem; margin: 0; }
        .card-body { margin-bottom: 1.5rem; }
        .card-footer { border-top: 1px solid var(--secondary); padding-top: 1rem; display: flex; justify-content: center; flex-wrap: wrap; gap: 0.5rem; }

        /* Form Elements */
        .form-group { margin-bottom: 1.5rem; }
        .form-control { display: block; width: 100%; padding: 0.75rem; font-size: 1rem; border: 1px solid var(--secondary); border-radius: var(--radius); transition: var(--transition); box-sizing: border-box; }
        .form-control:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.2); }
        #quizId, #userName { width: 100%; margin: 0; padding: 0.75rem; }
        .center-button { text-align: center; }

        /* Buttons */
        .btn { display: inline-block; font-weight: 500; text-align: center; vertical-align: middle; user-select: none; padding: 0.75rem 1.5rem; font-size: 1rem; line-height: 1.5; border-radius: var(--radius); transition: var(--transition); cursor: pointer; border: none; }
        .btn-primary { background-color: var(--primary); color: white; }
        .btn-primary:hover { background-color: var(--primary-hover); }
        .btn-secondary { background-color: var(--secondary); color: var(--text-primary); }
        .btn-secondary:hover { background-color: #d1d5db; }

        /* Quiz Screen Specific Styles */
       #quizScreen {
            position: relative;
            overflow: hidden; /* Contain absolute elements */
            /* min-height: 70vh; */ /* Line removed */
            flex-grow: 1; /* Allow quiz screen to expand */ /* <-- ADD THIS LINE */
            background: linear-gradient(180deg, #e0f7fa 0%, #b3e5fc 100%); /* Light blue gradient bg */
            display: flex; /* Add this to make gameArea sizing easier if needed */
            flex-direction: column; /* Stack header/progress/gameArea vertically */
        }
        
        .quiz-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem; padding: 0.5rem; background: rgba(255, 255, 255, 0.7); border-radius: var(--radius); position: relative; z-index: 20; /* Above game area */ }
        .timer-container, .quiz-title-display, .question-counter { display: flex; align-items: center; gap: 0.5rem; font-weight: 600; color: var(--text-secondary); padding: 0.5rem 1rem; background: var(--light); border-radius: var(--radius); }
        .timer-container i { color: var(--primary); }
        .timer-value { color: var(--text-primary); }
        .quiz-instructions { margin: 0.5rem 0 1rem 0; padding: 0.75rem; background-color: rgba(26, 115, 232, 0.1); border-left: 4px solid var(--primary); border-radius: 0 var(--radius) var(--radius) 0; font-size: 0.875rem; color: var(--text-secondary); position: relative; z-index: 20; /* Above game area */}
        .progress-container { width: 100%; height: 8px; background-color: var(--secondary); border-radius: 4px; overflow: hidden; margin-bottom: 1rem; position: relative; z-index: 20; /* Above game area */}
        .progress-bar { height: 100%; background-color: var(--primary); transition: width 0.3s ease; }

        #gameArea {
            position: relative; /* Back to relative positioning */ /* <-- CHANGED */
            /* top: 0; left: 0; right: 0; bottom: 0; */ /* Removed */
            flex-grow: 1; /* Make game area fill remaining vertical space */ /* <-- ADDED */
            border: none;
            border-radius: var(--radius);
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><path fill="%23d1d5db" fill-opacity="0.1" d="M10 10 H90 V90 H10Z M0 0 H100 V100 H0Z" /></svg>');
            overflow: hidden;
            /* z-index no longer strictly needed unless overlap issues arise */
            /* You might want margin-top if needed: */
            /* margin-top: 0.5rem;  */
        }


        /* Target Animations */
        @keyframes targetHitCorrect {
            0% { transform: scale(1) rotate(0deg); opacity: 1; background-color: var(--success); }
            50% { transform: scale(1.3) rotate(15deg); opacity: 0.5; }
            100% { transform: scale(0.5) rotate(-15deg); opacity: 0; background-color: var(--success); }
        }
        .target-hit-correct {
            animation: targetHitCorrect 0.5s ease-out forwards;
            pointer-events: none; /* Prevent hitting again during animation */
        }

        @keyframes targetHitIncorrect { /* Simple shake and fade */
             0% { transform: translateX(0); opacity: 1; background-color: var(--danger); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-8px); }
            80% { transform: translateX(8px); }
            100% { transform: translateX(0); opacity: 0; background-color: var(--danger); }
        }
        .target-hit-incorrect {
            animation: targetHitIncorrect 0.5s linear forwards;
            pointer-events: none; /* Prevent hitting again during animation */
        }

        /* --- MODIFICATION 1: Make Targets Circular --- */
        .target {
            position: absolute; /* Positioned within gameArea */
            /* padding: 0.6rem 1.2rem; */ /* Remove or adjust this */
            padding: 0.8rem; /* Make padding uniform for circle */
            width: auto; /* Let width be determined by content */
            min-width: 3rem; /* Ensure a minimum size */
            aspect-ratio: 1 / 1; /* Force it into a square shape */
            display: flex; /* Needed for centering text in aspect-ratio circle */
            justify-content: center; /* Center text horizontally */
            align-items: center; /* Center text vertically */
            background-color: var(--accent);
            color: var(--target-text-color);
            /* border-radius: 50px; */ /* REMOVE Pill shape */
            border-radius: 50%;   /* ADD THIS for Circle shape */
            font-family: var(--word-box-font-family);
            font-size: calc(var(--word-box-font-size) * 0.8); /* Adjust if text overflows */
            transition: transform 0.2s ease, background-color 0.2s ease; /* Keep for animations */
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 5;
            user-select: none; /* Prevent text selection */
            white-space: nowrap; /* Prevent wrapping */
            text-align: center; /* Ensure text centers if it somehow wraps */
        }

        /* --- MODIFICATION 2: Adjust Shooter and Add Triangle Pointer --- */
        #shooter {
            position: absolute;
            bottom: 10px;
            left: 50%; /* Initial position set by JS */
            padding: 0.8rem 1.8rem; /* Keep padding for text */
            background-color: var(--dark);
            color: var(--shooter-text-color);
            border-radius: 4px 4px 0 0; /* Change radius for a flatter bottom */
            font-family: var(--word-box-font-family);
            font-size: var(--word-box-font-size);
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 10;
            /* border-top: 3px solid var(--primary); */ /* REMOVE or change this border */
            white-space: nowrap; /* Prevent wrapping */
            /* ADD position: relative; if not already there (absolute is fine too) */
        }

        /* ADD THIS NEW RULE for the triangle */
        #shooter::before {
            content: ''; /* Required for pseudo-elements */
            position: absolute;
            width: 0;
            height: 0;
            border-left: 15px solid transparent;  /* Adjust size as needed */
            border-right: 15px solid transparent; /* Adjust size as needed */
            border-bottom: 15px solid var(--dark); /* Color matches shooter, creates upward triangle */
            bottom: 100%; /* Position it right above the shooter rectangle */
            left: 50%;    /* Center the triangle horizontally */
            transform: translateX(-50%); /* Fine-tune centering */
        }

        /* Optional: Style bullet slightly differently */
        .bullet-visual {
            position: absolute;
            width: 6px; /* Slimmer */
            height: 12px; /* Shorter */
            background: black; 
            /* background: linear-gradient(to top, var(--warning), gold); */ /* Gradient */
            border-radius: 50% 50% 0 0; /* More rounded top */
            /* box-shadow: 0 0 6px yellow; */
            z-index: 9;
            pointer-events: none; /* Don't block clicks */
            display: none; /* Keep hidden for the template */
        }
        /* Results Screen (Mostly reused styles) */
        .result-summary { padding: 1.5rem; background-color: #f3f4f6; border-radius: var(--radius); margin-bottom: 1.5rem; }
        .result-stat { display: flex; align-items: center; margin-bottom: 0.75rem; }
        .result-stat i { margin-right: 0.75rem; color: var(--primary); width: 24px; text-align: center; }
        .results-table-container { overflow-x: auto; margin-bottom: 1.5rem; }
        .results-table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
        .results-table th, .results-table td { padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--secondary); }
        .results-table th { background-color: #f9fafb; font-weight: 600; color: var(--text-secondary); }
        .results-table tr:hover td { background-color: #f3f4f6; }
        .results-table td.correct { color: var(--success); font-weight: bold; }
        .results-table td.incorrect { color: var(--danger); font-style: italic; }
        .results-table td.failed { color: var(--danger); font-style: italic; } /* For failed questions */

        /* Divider */
        .divider { display: flex; align-items: center; margin: 1.5rem 0; color: var(--text-secondary); font-size: 0.875rem; }
        .divider::before, .divider::after { content: ""; flex: 1; border-bottom: 1px solid var(--secondary); }
        .divider::before { margin-right: 1rem; }
        .divider::after { margin-left: 1rem; }

        /* Google Sheet Dropdown Styling */
        #quizSelect { /* Style reused */ width: 100%; padding: 0.75rem; font-size: 1rem; border: 1px solid var(--secondary); border-radius: var(--radius); transition: var(--transition); background-color: white; color: var(--text-primary); appearance: none; -webkit-appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%236b7280'%3E%3Cpath d='M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 0.75rem top 50%; background-size: 1.25rem; }
        #quizSelect:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.2); }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .card { padding: 1.5rem; }
            .quiz-header { flex-direction: column; align-items: flex-start; width: 100%; }
            .timer-container, .quiz-title-display, .question-counter { width: 100%; box-sizing: border-box; margin: 0.25rem 0; padding: 0.5rem; font-size: 0.875rem; justify-content: center; }
            /* Game area height is determined by absolute positioning now */
            #shooter { padding: 0.7rem 1.5rem; font-size: calc(var(--word-box-font-size) * 0.9); bottom: 5px;}
            .target { padding: 0.5rem 1rem; font-size: calc(var(--word-box-font-size) * 0.8); }
            .results-table th, .results-table td { padding: 0.5rem; font-size: 0.75rem; }
        }
        @media (max-width: 480px) {
            h1 { font-size: 1.8rem; }
            .card-footer { justify-content: center; }
            .btn { width: 100%; margin-bottom: 0.5rem; }
            /* Game area height is determined by absolute positioning now */
             #shooter { padding: 0.6rem 1.2rem; font-size: calc(var(--word-box-font-size) * 0.8); bottom: 2px;}
            .target { padding: 0.4rem 0.8rem; font-size: calc(var(--word-box-font-size) * 0.7); }
            .quiz-title-display { font-size: 0.8rem; }
        }
/* Add Mobile Controls CSS Here */
        #mobile-controls {
            position: absolute; /* Position relative to #quizScreen */
            bottom: 5px;       /* Small gap from bottom */
            left: 10px;        /* Padding from left edge */
            right: 10px;       /* Padding from right edge */
            height: 60px;      /* Height for positioning buttons inside, adjust if needed */
            z-index: 100;      /* Ensure controls are above game elements */
            pointer-events: none; /* Allow clicks/touches to pass through the container background */
            display: none;     /* Hide by default */
        }

        /* Show controls only when quiz screen is active */
        #quizScreen.active #mobile-controls {
            display: block; /* Use block display when active */
        }

        #mobile-controls button {
            position: absolute;
            bottom: 0; /* Align buttons to the bottom of the #mobile-controls container */
            width: 55px;       /* Button size */
            height: 55px;
            background-color: rgba(100, 100, 100, 0.6); /* Semi-transparent grey */
            border: none;
            border-radius: 50%; /* Circular buttons */
            color: white;      /* White icon color */
            font-size: 1.4rem; /* Icon size */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto; /* Make buttons interactive (override container's none) */
            user-select: none;    /* Prevent text selection on hold */
            -webkit-user-select: none;
            touch-action: manipulation; /* Improve touch responsiveness, prevent double-tap zoom */
            transition: background-color 0.1s ease;
        }

        /* Style for button press */
        #mobile-controls button:active {
            background-color: rgba(60, 60, 60, 0.8); /* Darker when pressed */
        }

        /* Position Fire Button */
        #mobile-fire {
            left: 0; /* Position fire button on the left edge of the container */
        }

        /* Position Right Arrow Button */
        #mobile-right {
            right: 0; /* Position right arrow on the right edge of the container */
        }

        /* Position Left Arrow Button */
        #mobile-left {
             right: 65px; /* Position left arrow next to right arrow (55px width + 10px gap) */
        }

        /* Hide original keyboard instructions on devices that likely don't have one */
        /* This uses a common media query for touch devices */
        @media (hover: none) and (pointer: coarse) {
            .quiz-instructions {
                display: none;
            }
        }
        /* END Mobile Controls CSS */
    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
             <h1><i class="fas fa-crosshairs rotate-icon"></i>
                <span class="fill-text">Language Shooter</span>
             </h1>
        </header>

        <!-- Landing Screen -->
        <div id="landingScreen" class="screen active">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Welcome to Language Shooter</h2>
                    <p>Take aim and match the words!</p>
                </div>
                <div class="card-body">
                    <!-- Quiz Selection -->
                    <div class="form-group">
                        <label for="quizSelect" class="form-label">Built-in Games:</label>
                        <select id="quizSelect" class="form-control"></select> <!-- Options populated by JS -->
                    </div>
                    <div class="center-button">
                        <button onclick="startSelectedQuiz()" class="btn btn-primary" disable> <!-- Initially disabled -->
                            <i class="fas fa-play-circle"></i> Start Built-in Game
                        </button>
                    </div>
                    <div class="divider">OR</div>

                    <div class="form-group">
                        <label for="quizId" class="form-label">Have a custom game?</label>
                        <p class="form-text" style="margin-top: 0.25rem; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.875rem;">
                            <i class="fas fa-info-circle"></i> Game ID is provided by your teacher
                        </p>
                        <input type="text" id="quizId" placeholder="Enter Game ID" class="form-control">
                    </div>
                </div>
                 <div class="center-button">
                    <button onclick="startCustomQuiz()" class="btn btn-secondary">
                        <i class="fas fa-file-import"></i> Start Custom Game
                    </button>
                </div>
            </div>
        </div>

        <!-- Name Screen -->
        <div id="nameScreen" class="screen">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Ready Player?</h2>
                </div>
                <div class="card-body">
                    <div class="form-group">
                        <label for="userName" class="form-label">Enter Your Name</label>
                        <input type="text" id="userName" required class="form-control" placeholder="Your Name">
                    </div>
                </div>
                <div class="card-footer">
                    <button onclick="startQuiz()" class="btn btn-primary">
                        <i class="fas fa-gamepad"></i> Start Game
                    </button>
                    <button onclick="goHome()" class="btn btn-secondary">
                        <i class="fas fa-home"></i> Back to Home
                    </button>
                </div>
            </div>
        </div>

        <!-- Quiz Screen -->
        <div id="quizScreen" class="screen">
             <!-- Header elements (now above game area) -->
            <div class="quiz-header">
                <div class="timer-container">
                    <i class="fas fa-clock"></i> Time: <span id="timer" class="timer-value">0</span>s
                </div>
                 <div id="quizTitleDisplay" class="quiz-title-display">
                     <!-- Quiz title will be shown here -->
                 </div>
                
                <div class="question-counter" id="questionNumber"></div>
                <div id="bulletCounter" class="bullet-counter" style="display: none; align-items: center; gap: 0.5rem; font-weight: 600; color: var(--text-secondary); padding: 0.5rem 1rem; background: var(--light); border-radius: var(--radius); margin-left: 1rem;"> {/* Added margin-left for spacing */}
                    <!-- Content set by JS -->
                </div>
            </div>
            <div id="progressContainer" class="progress-container">
                <div id="progressBar" class="progress-bar" style="width: 0%"></div>
            </div>
             <div class="quiz-instructions">
                <i class="fas fa-arrows-alt-h"></i> Move: Left/Right Arrows    <i class="fas fa-keyboard"></i> Fire: Spacebar
            </div>

            <!-- Game Area -->
            <div id="gameArea">
                 <!-- Shooter -->
                <div id="shooter">
                    <!-- Current Column A word here -->
                </div>

                <!-- Bullet Element (initially hidden) -->
                <div id="bullet" class="bullet-visual"></div>

                <!-- Targets will be added here by JS -->
                <!-- START: Add Mobile Controls HTML -->
                <div id="mobile-controls">
                    <button id="mobile-fire" aria-label="Fire"><i class="fas fa-crosshairs"></i></button>
                    <button id="mobile-left" aria-label="Move Left"><i class="fas fa-arrow-left"></i></button>
                    <button id="mobile-right" aria-label="Move Right"><i class="fas fa-arrow-right"></i></button>
                </div>
                <!-- END: Add Mobile Controls HTML -->
            </div>
        </div>

        <!-- Results Screen -->
        <div id="resultsScreen" class="screen">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Game Results</h2>
                </div>
                <div class="card-body">
                    <div class="result-summary" id="resultSummary">
                        <!-- Results summary will be inserted here -->
                    </div>

                    <div class="results-table-container">
                        <table id="resultsTable" class="results-table">
                            <!-- Results table will be inserted here -->
                        </table>
                    </div>
                </div>
                <div class="card-footer">
                    <button onclick="screenshotResults()" class="btn btn-secondary">
                        <i class="fas fa-camera"></i> Screenshot Results
                    </button>
                    <button onclick="reviewQuestions()" class="btn btn-primary">
                        <i class="fas fa-redo"></i> Play Again
                    </button>
                     <button onclick="goHome()" class="btn btn-secondary">
                        <i class="fas fa-home"></i> Back to Home
                    </button>
                </div>
            </div>
        </div>

        <footer class="app-footer">
            <div id="visitor-counter">
               Welcome! You're visitor #<span id="pageviews">Loading...</span>
            </div>
            <p><a href="https://linsnotes.com">linsnotes.com</a></p>
        </footer>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.4/xlsx.full.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script data-goatcounter="https://linsnotes.goatcounter.com/count" async src="https://gc.zgo.at/count.js"></script>

    <script>
        // --- Global State ---
        let currentQuestion = 0;
        let quizData = []; // Array of { colA: "word1", colB: "match1" }
        let allColBTargets = []; // Array of all unique Column B words for target generation
        let userData = { name: '', startTime: 0, attempts: [], totalPoints: 0 }; // Attempts: { question: num, colA: str, correctAnswer: str, time: sec, points: num, attempts: num, status: 'correct' | 'failed' | 'skipped' }
        let timerInterval;
        let timerPaused = false;
        let elapsedTime = 0;
        let questionStartTime = 0; // Track start time for each question
        let questionAttempts = {}; // Tracks shots fired per question index { index: count }
        let questionFailed = false; // Flag if the current question failed due to target reaching bottom

        // --- Constants & Config ---
        const QUIZ_LIST_SHEET_ID = '1b_yzMM-qy_g9Sa-kO5mPtAL67neZdaIW_QIQcfFHaNg'; // Replace if needed
        const SHOOTER_MOVE_SPEED = 15; // Pixels per keydown event
        const BULLET_SPEED = 12; // Pixels per frame
        const TARGET_DOWNWARD_SPEED = 0.5; // Pixels per frame
        const TARGET_HORIZONTAL_SPEED_MAX = 1.0; // Max horizontal pixels per frame
        const TARGET_SPAWN_Y_OFFSET = -50; // Start targets slightly above the screen
        const TARGET_FAILURE_PADDING = 20; // How close target needs to get to shooter top to fail
        let numberOfOptions = 4; // Default target count

        // --- NEW CONSTANTS FOR POPUP TIMERS ---
        const POPUP_TIMER_CORRECT_MS = 1200;    // Duration for the "Correct!" popup (milliseconds)
        const POPUP_TIMER_INCORRECT_MS = 1200;  // Duration for the "Incorrect!" popup (milliseconds)

        // --- Game State ---
        let gameLoopId = null;
        let shooterX = 0; // Current horizontal position (pixels from left)
        let unlimitedBulletsEnabled = false; // default to limited
        let activeBullets = []; // Array of { element: DOMEl, x: num, y: num, width: num, height: num } // ADD THIS LINE
        let activeTargets = []; // Array of { element: DOMEl, x: num, y: num, vx: num, vy: num, word: str, hit: bool }
        let keysPressed = {}; // Track pressed keys for smoother movement
        let gameActive = false; // Is the game loop running?

        // --- DOM Cache ---
        const DOMElements = {
            landingScreen: document.getElementById('landingScreen'),
            nameScreen: document.getElementById('nameScreen'),
            quizScreen: document.getElementById('quizScreen'),
            resultsScreen: document.getElementById('resultsScreen'),
            quizSelect: document.getElementById('quizSelect'),
            quizIdInput: document.getElementById('quizId'),
            userNameInput: document.getElementById('userName'),
            timerDisplay: document.getElementById('timer'),
            quizTitleDisplay: document.getElementById('quizTitleDisplay'),
            questionNumberDisplay: document.getElementById('questionNumber'),
            progressBar: document.getElementById('progressBar'),
            gameArea: document.getElementById('gameArea'),
            shooter: document.getElementById('shooter'),
            bulletTemplate: document.getElementById('bullet'), 
            bulletCounter: document.getElementById('bulletCounter'),
            resultSummary: document.getElementById('resultSummary'),
            resultsTable: document.getElementById('resultsTable'),
            startBuiltInButton: document.querySelector('button[onclick="startSelectedQuiz()"]'),
            appHeader: document.querySelector('.app-header'),
            appFooter: document.querySelector('.app-footer'),
            // START: Add mobile control elements
            mobileControls: document.getElementById('mobile-controls'),
            mobileLeft: document.getElementById('mobile-left'),
            mobileRight: document.getElementById('mobile-right'),
            mobileFire: document.getElementById('mobile-fire')
            // END: Add mobile control elements
        };

        // --- Computed Styles Cache ---
        const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary').trim();
        const textSecondary = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadQuizTitlesAndIds();
            // Add keyboard listeners globally, but only act when gameActive
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            // START: Add Mobile Controls Setup Function
            function setupMobileControls() {
                const leftBtn = DOMElements.mobileLeft;
                const rightBtn = DOMElements.mobileRight;
                const fireBtn = DOMElements.mobileFire;

                // Basic check if elements exist
                if (!leftBtn || !rightBtn || !fireBtn) {
                    // Hide the container if buttons aren't found, or log warning
                    if(DOMElements.mobileControls) DOMElements.mobileControls.style.display = 'none';
                    console.warn("Mobile control buttons not found. Controls disabled.");
                    return;
                }

                // --- Movement Button Listeners (Hold to Move) ---
                const handleMoveStart = (e, direction) => {
                    if (!gameActive) return;
                    e.preventDefault(); // Prevent screen scroll/zoom on touch
                    if (direction === 'left') {
                        keysPressed['ArrowLeft'] = true;
                        keysPressed['ArrowRight'] = false; // Ensure only one direction
                    } else {
                        keysPressed['ArrowRight'] = true;
                        keysPressed['ArrowLeft'] = false; // Ensure only one direction
                    }
                };

                const handleMoveEnd = (e, direction) => {
                    if (!gameActive) return;
                    // No preventDefault needed usually on end events
                    if (direction === 'left') {
                        keysPressed['ArrowLeft'] = false;
                    } else {
                        keysPressed['ArrowRight'] = false;
                    }
                };

                // Left Button
                leftBtn.addEventListener('touchstart', (e) => handleMoveStart(e, 'left'), { passive: false });
                leftBtn.addEventListener('touchend', (e) => handleMoveEnd(e, 'left'));
                leftBtn.addEventListener('touchcancel', (e) => handleMoveEnd(e, 'left')); // Handle interruption

                // Right Button
                rightBtn.addEventListener('touchstart', (e) => handleMoveStart(e, 'right'), { passive: false });
                rightBtn.addEventListener('touchend', (e) => handleMoveEnd(e, 'right'));
                rightBtn.addEventListener('touchcancel', (e) => handleMoveEnd(e, 'right')); // Handle interruption

                // --- Fire Button Listener (Tap to Fire) ---
                fireBtn.addEventListener('touchstart', (e) => {
                    if (!gameActive) return;
                    e.preventDefault(); // Prevent screen scroll/zoom
                    fireBullet(); // Directly call the existing fire function
                }, { passive: false });

                // Optional: Add mouse events for desktop testing/hybrid devices
                leftBtn.addEventListener('mousedown', (e) => handleMoveStart(e, 'left'));
                leftBtn.addEventListener('mouseup', (e) => handleMoveEnd(e, 'left'));
                leftBtn.addEventListener('mouseleave', (e) => handleMoveEnd(e, 'left')); // Stop if mouse leaves while pressed

                rightBtn.addEventListener('mousedown', (e) => handleMoveStart(e, 'right'));
                rightBtn.addEventListener('mouseup', (e) => handleMoveEnd(e, 'right'));
                rightBtn.addEventListener('mouseleave', (e) => handleMoveEnd(e, 'right'));

                fireBtn.addEventListener('mousedown', (e) => { // Use mousedown for fire as well
                     if (!gameActive) return;
                     fireBullet();
                });

            }
            // END: Add Mobile Controls Setup Function

            // Call the setup function after caching elements
            setupMobileControls();



 
            // pageviews counter
            const pv = document.getElementById('pageviews');

            if (pv !== null) {
                const uri = location.pathname.replace(/\/$/, '');
                const url = `https://linsnotes.goatcounter.com/counter/${encodeURIComponent(uri)}.json`;

                fetch(url)
                    .then((response) => response.json())
                    .then((data) => {
                        const count = data.count.replace(/\s/g, '');
                        pv.innerText = new Intl.NumberFormat().format(count);
                    })
                    .catch((error) => {
                        pv.innerText = '1';
                    });
            }
        });

        // --- Screen Management ---
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const targetScreen = DOMElements[screenId];
            if (targetScreen) {
                targetScreen.classList.add('active');
            } else {
                console.error(`Screen with ID ${screenId} not found.`);
                DOMElements.landingScreen.classList.add('active'); // Fallback
            }
            const showHeaderFooter = (screenId !== 'quizScreen');
            DOMElements.appHeader.style.display = showHeaderFooter ? 'block' : 'none';
            DOMElements.appFooter.style.display = showHeaderFooter ? 'block' : 'none';
            gameActive = (screenId === 'quizScreen'); // Control game loop activity
        }

        function goHome() {
            stopGameLoop();
            resetQuizState();
            DOMElements.quizIdInput.value = '';
            DOMElements.quizSelect.selectedIndex = 0;
            DOMElements.startBuiltInButton.disabled = true;
            DOMElements.appHeader.style.display = 'block';
            DOMElements.appFooter.style.display = 'block';
            showScreen('landingScreen');
        }

        // --- Data Loading ---
        async function loadSheetData(sheetId) {
                try {
                        const url = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
                        const response = await fetch(url);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        const csv = await response.text();
                        const workbook = XLSX.read(csv, { type: 'string' });
                        const sheetName = workbook.SheetNames[0];
                        if (!sheetName) throw new Error('No sheet found.');

                        // header: 1 reads rows as arrays, 0-indexed
                        const rows = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });

                        // Existing title read
                        window.quizTitle = rows?.[0]?.[0]?.trim() || `Quiz (${sheetId.substring(0, 6)}...)`;

                        // ---> Read number of options from C1 <---
                        const optionsCellValue = rows?.[0]?.[2]; // Cell C1 is at index 2 in the first row (index 0)
                        let parsedOptions = parseInt(optionsCellValue, 10); // Attempt to parse as integer

                        if (isNaN(parsedOptions) || parsedOptions < 1) {
                                // If C1 is empty, not a number, or less than 1, use the default
                                numberOfOptions = 4;
                                console.log("Cell C1 is empty or invalid. Defaulting to 4 target options.");
                        } else {
                                // Otherwise, use the valid number from C1
                                numberOfOptions = parsedOptions;
                                console.log(`Number of target options read from C1: ${numberOfOptions}`);
                        }
                        // Ensure numberOfOptions is at least 1 (to show the correct answer)
                        if (numberOfOptions < 1) {
                            console.warn("numberOfOptions was less than 1, setting to 1.");
                            numberOfOptions = 1;
                        }
                        // ---> read from C1 <---

                        // ---> Read D1 for Unlimited Bullets <---
                        const unlimitedCellValue = rows?.[0]?.[3]; // Cell D1 (0-indexed column 3)
                        // Check if the cell has *any* text content after trimming whitespace
                        if (unlimitedCellValue !== undefined && unlimitedCellValue !== null && String(unlimitedCellValue).trim() !== '') {
                                unlimitedBulletsEnabled = true;
                                console.log("Cell D1 is not empty. Unlimited bullets ENABLED.");
                        } else {
                                unlimitedBulletsEnabled = false;
                                console.log("Cell D1 is empty. Limited bullets ENABLED.");
                        }
                        // ---> END READ D1 <---

                    
                        // Existing data processing
                        const data = rows.slice(1) // Start from the second row for actual quiz data
                                .map(row => ({
                                        colA: row[0] ? String(row[0]).trim() : null,
                                        colB: row[1] ? String(row[1]).trim() : null
                                        // Column C (index 2) is ignored here for quiz data itself
                                }))
                                .filter(item => item.colA && item.colB);

                        if (data.length === 0) {
                                console.warn('Sheet has no valid data rows.'); return null;
                        }
                        // Store all unique Column B values for targets (remains the same)
                        allColBTargets = [...new Set(data.map(item => item.colB))];
                        return data;
                } catch (error) {
                        console.error('Error loading sheet data:', error);
                        Swal.fire('Error Loading Game', `Could not load game data [${sheetId}]. Check ID/sharing. Details: ${error.message}`, 'error', { confirmButtonColor: primaryColor });
                        return null;
                }
        }

        async function loadQuizTitlesAndIds() {
             if (!QUIZ_LIST_SHEET_ID || QUIZ_LIST_SHEET_ID === 'YOUR_QUIZ_LIST_SHEET_ID_HERE') { // Check if ID is set
                console.warn("Quiz/Game List Sheet ID not set. Disabling built-in quiz/game option.");
                DOMElements.quizSelect.innerHTML = '<option value="" disabled selected>Built-in Games Unavailable</option>';
                DOMElements.quizSelect.disabled = true;
                DOMElements.startBuiltInButton.disabled = true;
                return;
             }
            try {
                const url = `https://docs.google.com/spreadsheets/d/${QUIZ_LIST_SHEET_ID}/export?format=csv&gid=0`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const csv = await response.text();
                const workbook = XLSX.read(csv, { type: 'string' });
                const sheetName = workbook.SheetNames[0];
                if (!sheetName) throw new Error('No sheet found for quiz list.');
                const rows = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });

                quizTitlesAndIds = rows.slice(1)
                    .map(row => ({ title: row[0]?.trim(), id: row[1]?.trim() }))
                    .filter(quiz => quiz.title && quiz.id);
                populateQuizSelect();
            } catch (error) {
                console.error('Error loading game titles:', error);
                 Swal.fire('Error Loading Game List', `Could not load built-in Games. Details: ${error.message}`, 'error', { confirmButtonColor: primaryColor });
                DOMElements.quizSelect.innerHTML = '<option value="" disabled selected>Error Loading Games</option>';
                DOMElements.quizSelect.disabled = true;
                DOMElements.startBuiltInButton.disabled = true;
            }
        }

        function populateQuizSelect() {
            const select = DOMElements.quizSelect;
            select.innerHTML = '';
            if (quizTitlesAndIds.length === 0) {
                select.innerHTML = '<option value="" disabled selected>No Built-in Games Found</option>';
                select.disabled = true;
                DOMElements.startBuiltInButton.disabled = true; return;
            }
            const defaultOption = document.createElement('option');
            defaultOption.value = ""; defaultOption.textContent = "-- Select a Built-in Game --";
            defaultOption.disabled = true; defaultOption.selected = true; select.appendChild(defaultOption);
            quizTitlesAndIds.forEach(quiz => {
                const option = document.createElement('option'); option.value = quiz.id; option.textContent = quiz.title; select.appendChild(option);
            });
            select.disabled = false; DOMElements.startBuiltInButton.disabled = true;
            select.addEventListener('change', function() {
                currentSheetId = this.value; DOMElements.quizIdInput.value = '';
                DOMElements.startBuiltInButton.disabled = !this.value;
            });
        }

        // --- Quiz Flow Control ---
        function startSelectedQuiz() {
            // Check if a built-in quiz is selected
            if (!currentSheetId) {
                // Use Swal.fire for the popup, matching the puzzle app style
                Swal.fire({
                    title: 'No Game Selected', // Changed title slightly for Shooter context
                    text: 'Please select a game from the dropdown list.', // Matched puzzle app text
                    icon: 'warning', // Matched puzzle app icon
                    confirmButtonColor: primaryColor // Use the cached primary color variable
                });
                return; // Stop the function here
            }
            // If a sheet ID is selected, proceed
            startQuizFlow(currentSheetId);
        }

        async function startCustomQuiz() {
            const sheetId = DOMElements.quizIdInput.value.trim();
            if (!sheetId) { Swal.fire('Missing Input', 'Please enter a Custom Quiz Google Sheet ID.', 'warning', { confirmButtonColor: primaryColor }); return; }
            currentSheetId = sheetId; startQuizFlow(sheetId);
        }
        async function startQuizFlow(sheetId) {
            Swal.fire({ title: 'Loading Game', text: 'Please wait...', allowOutsideClick: false, showConfirmButton: false, willOpen: () => Swal.showLoading() });
            const data = await loadSheetData(sheetId);
            if (!data || data.length === 0) {
                Swal.close(); if (data !== null) { Swal.fire('Empty or Invalid Quiz', 'No valid questions found.', 'warning', { confirmButtonColor: primaryColor }); } return;
            }
            quizData = data;
            resetQuizState(false); // Reset state but keep name/sheetId if already entered
            Swal.close();
            showScreen('nameScreen');
        }

        // --- UPDATED resetQuizState Function ---
        function resetQuizState(fullReset = true) {
                stopGameLoop(); // Ensure loop is stopped
                clearInterval(timerInterval);
                currentQuestion = 0;
                quizData = fullReset ? [] : quizData;
                allColBTargets = fullReset ? [] : allColBTargets;
                userData.startTime = 0;
                userData.attempts = [];
                userData.totalPoints = 0;
                timerInterval = null;
                timerPaused = false;
                elapsedTime = 0;
                questionStartTime = 0;
                questionAttempts = {};
                questionFailed = false;
                currentCorrectAnswer = '';
                activeTargets = []; // Clear active targets array
                // ---> ADD THIS: Clear active bullets (DOM and Array) <---
                activeBullets.forEach(b => {
                        if (b.element && b.element.parentNode) {
                                b.element.remove();
                        }
                });
                activeBullets = [];
                // ---> END ADD <---

                keysPressed = {}; // Clear pressed keys

                if (fullReset) {
                        userData.name = ''; currentSheetId = ''; window.quizTitle = '';
                }

                // Clear UI elements
                DOMElements.resultSummary.innerHTML = '';
                DOMElements.resultsTable.innerHTML = '';

                // Clear dynamically added children from gameArea (targets, bullets)
                // Keep shooter and bullet template
                Array.from(DOMElements.gameArea.children).forEach(child => {
                        // Check against the cached elements
                        if (child !== DOMElements.shooter && child !== DOMElements.bulletTemplate) {
                                child.remove();
                        }
                });

                // Reset other UI specific to the quiz screen
                DOMElements.shooter.textContent = '';
                DOMElements.progressBar.style.width = '0%';
                DOMElements.timerDisplay.textContent = '0';
                DOMElements.questionNumberDisplay.textContent = '';
                DOMElements.quizTitleDisplay.textContent = '';

                 // ---> Reset Bullet Counter UI <---
                 const bulletCounterEl = DOMElements.bulletCounter; // Use cached element
                 if (bulletCounterEl) {
                     bulletCounterEl.style.display = 'none'; // Hide it
                     bulletCounterEl.innerHTML = ''; // Clear content
                 }
                 // ---> END Reset Bullet Counter UI <---
            
                // Ensure the bullet template remains hidden (CSS should primarily handle this)
                if (DOMElements.bulletTemplate) {
                        DOMElements.bulletTemplate.style.display = 'none';
                }
        }

        
        function startQuiz() {
            userData.name = DOMElements.userNameInput.value.trim();
            if (!userData.name) { Swal.fire('Missing Input', 'Please enter your name.', 'warning', { confirmButtonColor: primaryColor }); return; }
            quizData.forEach((_, idx) => { questionAttempts[idx] = 0; });
            showScreen('quizScreen');
            DOMElements.quizTitleDisplay.textContent = window.quizTitle || 'Language Shooter';
            positionShooter(); // Set initial shooter position
            loadQuestion(); // Will also start the game loop
            startTimer(); // Start the overall quiz timer
        }

        // --- Game Logic ---
        function positionShooter() {
            const gameAreaWidth = DOMElements.gameArea.clientWidth;
            const shooterWidth = DOMElements.shooter.offsetWidth;
            shooterX = (gameAreaWidth - shooterWidth) / 2; // Center initial position
            DOMElements.shooter.style.left = `${shooterX}px`;
        }

        // --- Updated loadQuestion function ---
        function loadQuestion() {
             // Stop previous loop if any - necessary to reset target/bullet state for the new question
             if (gameLoopId) {
                 cancelAnimationFrame(gameLoopId);
                 gameLoopId = null; // Explicitly clear the ID
             }

             gameActive = true; // Ensure game is active for this screen
             questionFailed = false; // Reset failure flag for the new question

             // Check if quiz is finished
             if (currentQuestion >= quizData.length) {
                 showResults(); // Assumes showResults exists
                 return;
             }

            // --- Clear old game elements FIRST ---
            clearGameElements(); // This will remove any remaining targets/bullet from the previous question

            // Get data for the current question
            const questionData = quizData[currentQuestion];
            currentCorrectAnswer = questionData.colB;

            // Update UI elements
            DOMElements.shooter.textContent = questionData.colA; // Assumes DOMElements cache exists

            // Reposition shooter after text content potentially changes its width
            // Use requestAnimationFrame to ensure accurate measurement after render
             requestAnimationFrame(() => {
                 positionShooter(); // Assumes positionShooter exists
             });

            // Update progress bar and question counter
            const progress = ((currentQuestion + 1) / quizData.length) * 100;
            DOMElements.progressBar.style.width = `${progress}%`; // Assumes DOMElements cache exists
            DOMElements.questionNumberDisplay.textContent = `Question ${currentQuestion + 1} of ${quizData.length}`; // Assumes DOMElements cache exists
            // ---> Update Bullet Counter UI <---
            const bulletCounterEl = DOMElements.bulletCounter; // Use cached element
            if (bulletCounterEl) { // Check if element exists in cache
                 bulletCounterEl.style.color = 'var(--text-secondary)'; // Reset color
                 bulletCounterEl.style.display = 'flex'; // Make sure it's visible

                 if (unlimitedBulletsEnabled) {
                      bulletCounterEl.innerHTML = `<i class="fas fa-infinity"></i> Unlimited`;
                 } else {
                      const shotsFired = questionAttempts[currentQuestion] || 0; // Get attempts for *this* question
                      const remaining = Math.max(0, numberOfOptions - shotsFired); // Ensure not negative
                      bulletCounterEl.innerHTML = `<i class="fas fa-crosshairs"></i> Bullets: ${remaining}/${numberOfOptions}`;
                      if (remaining <= 0) {
                           bulletCounterEl.style.color = 'var(--danger)'; // Optional: Indicate zero remaining
                      }
                 }
            } else {
                 console.warn("Bullet counter element not found in DOM cache.");
            }
            // ---> END Update Bullet Counter UI <---

            // Prepare and display NEW targets for the current question
            spawnTargets(); // Assumes spawnTargets exists

            // Reset timer for the question & ensure the overall timer is running
            questionStartTime = Date.now();
            resumeTimer(); // Assumes resumeTimer exists (ensures timer is not paused)

            // Start the game loop for this new question
            startGameLoop(); // Assumes startGameLoop exists
        }

        function clearGameElements() {
                // Remove target DOM elements (existing code)
                activeTargets.forEach(t => {
                        if (t.element && t.element.parentNode) { // Check if element exists and is in DOM
                                t.element.remove();
                        }
                });
                activeTargets = [];

                // ---> ADD THIS: Remove active bullet DOM elements <---
                activeBullets.forEach(b => {
                        if (b.element && b.element.parentNode) { // Check if element exists and is in DOM
                                b.element.remove();
                        }
                });
                activeBullets = []; // Clear the tracking array
                // ---> END ADD <---

                // Hide bullet TEMPLATE (redundant if CSS handles it, but safe)
                // if (DOMElements.bulletTemplate) {
                //     DOMElements.bulletTemplate.style.display = 'none';
                // }
        }



        function spawnTargets() {
                const gameArea = DOMElements.gameArea;
                const areaWidth = gameArea.clientWidth;
                const areaHeight = gameArea.clientHeight; // Use for Y spawning

                // Clear any remnants from previous question (though clearGameElements should handle this)
                activeTargets.forEach(t => t.element.remove());
                activeTargets = [];

                // ---> START TARGET SELECTION LOGIC <---

                const correctAnswer = currentCorrectAnswer; // Get the correct answer for the current question

                // Filter out the correct answer to get only potential incorrect options
                let incorrectOptions = allColBTargets.filter(target => target !== correctAnswer);

                // Shuffle the available incorrect options
                incorrectOptions = shuffle(incorrectOptions);

                // Determine how many incorrect options we need (total options - 1 for the correct one)
                // Ensure it's not negative if numberOfOptions is 1
                const numberOfIncorrectNeeded = Math.max(0, numberOfOptions - 1);

                // Select the required number of incorrect options
                // .slice will handle cases where fewer incorrect options are available than needed
                const selectedIncorrect = incorrectOptions.slice(0, numberOfIncorrectNeeded);

                // Combine the correct answer with the selected incorrect ones
                // Handle the case where the correct answer might be the ONLY option available in the sheet
                let finalTargetsToShow = [];
                if (allColBTargets.includes(correctAnswer)) {
                        finalTargetsToShow = [correctAnswer, ...selectedIncorrect];
                } else {
                        // Fallback: if the correct answer isn't even in the list (shouldn't happen with current logic, but safe)
                        finalTargetsToShow = selectedIncorrect.slice(0, numberOfOptions); // Just show incorrect ones up to the limit
                        console.warn("Correct answer was not found in allColBTargets list.");
                }

                // Ensure the total number of targets doesn't exceed numberOfOptions
                // This mainly handles edge cases like numberOfOptions=1 or very few unique Col B values.
                finalTargetsToShow = finalTargetsToShow.slice(0, numberOfOptions);

                // Shuffle the final list so the correct answer's position is random
                finalTargetsToShow = shuffle(finalTargetsToShow);

                console.log(`Spawning ${finalTargetsToShow.length} targets (requested ${numberOfOptions}):`, finalTargetsToShow); // Optional: for debugging

                // Now, create target elements ONLY for the words in finalTargetsToShow
                finalTargetsToShow.forEach(targetWord => {
                        const targetElement = document.createElement('div');
                        targetElement.className = 'target';
                        targetElement.textContent = targetWord;
                        targetElement.dataset.word = targetWord; // Store word

                        gameArea.appendChild(targetElement); // Add to DOM first to measure width

                        const targetWidth = targetElement.offsetWidth;
                        const targetHeight = targetElement.offsetHeight; // Store height

                        // Initial Position (Random X, slightly above screen)
                        // Ensure targets don't overlap too much horizontally initially if many targets
                        let x;
                        let attempts = 0;
                        const maxAttempts = 10; // Prevent infinite loop if space is tight
                        let placed = false;

                        do {
                            x = Math.random() * (areaWidth - targetWidth);
                            placed = true;
                            // Basic check against already placed targets in this spawn cycle
                            // Note: This isn't perfect collision avoidance but helps initial spread
                            activeTargets.forEach(existingTarget => {
                                if (Math.abs(x - existingTarget.x) < (targetWidth + existingTarget.width) / 2) { // Approximate horizontal overlap check
                                    placed = false;
                                }
                            });
                            attempts++;
                        } while (!placed && attempts < maxAttempts);

                        // If we failed to find a non-overlapping spot after attempts, just use the last random X
                        if (!placed) {
                            x = Math.random() * (areaWidth - targetWidth);
                        }

                        // Spread out initial Y based on height and randomness
                        const y = TARGET_SPAWN_Y_OFFSET - (Math.random() * areaHeight * 0.3) - (targetHeight * activeTargets.length * 0.1);

                        // Initial Velocity (Random horizontal, constant downward)
                        const vx = (Math.random() * 2 - 1) * TARGET_HORIZONTAL_SPEED_MAX; // -Max to +Max
                        const vy = TARGET_DOWNWARD_SPEED;

                        targetElement.style.left = `${x}px`;
                        targetElement.style.top = `${y}px`;

                        activeTargets.push({
                                element: targetElement,
                                x: x, y: y,
                                vx: vx, vy: vy,
                                word: targetWord,
                                width: targetWidth, // Store dimensions for collision
                                height: targetHeight,
                                hit: false // Flag to prevent multiple hits/checks
                        });
                });

                // ---> END TARGET SELECTION LOGIC <---
        }

        // --- Input Handling ---
        function handleKeyDown(event) {
            if (!gameActive) return; // Only handle keys during the quiz screen
            keysPressed[event.code] = true;

            // Handle firing immediately on Space press down
            if (event.code === 'Space') {
                fireBullet();
                event.preventDefault(); // Prevent scrolling page down
            }
        }
        function handleKeyUp(event) {
            if (!gameActive) return;
            keysPressed[event.code] = false;
        }

        function updateShooterPosition() {
            const gameAreaWidth = DOMElements.gameArea.clientWidth;
            const shooterWidth = DOMElements.shooter.offsetWidth;
            const moveAmount = SHOOTER_MOVE_SPEED; // Adjust speed here

            if (keysPressed['ArrowLeft'] || keysPressed['KeyA']) {
                shooterX -= moveAmount;
            }
            if (keysPressed['ArrowRight'] || keysPressed['KeyD']) {
                shooterX += moveAmount;
            }

            // Keep shooter within bounds
            shooterX = Math.max(0, Math.min(shooterX, gameAreaWidth - shooterWidth));

            DOMElements.shooter.style.left = `${shooterX}px`;
        }

        function fireBullet() {
            // REMOVED: if (bulletState.active) return; // No longer limiting to one bullet
            // ---> ADD BULLET LIMIT CHECK & POPUP TRIGGER <---
            if (!unlimitedBulletsEnabled) {
                 const shotsFired = questionAttempts[currentQuestion] || 0;
                 if (shotsFired >= numberOfOptions) {
                      console.log("Attempted to fire with no bullets left.");
                      showOutOfBulletsPopup(); // <--- CALL THE NEW POPUP FUNCTION
                      return; // Stop execution here, don't fire
                 }
            }
            // ---> END BULLET LIMIT CHECK <---

            
            questionAttempts[currentQuestion]++; // Count every shot as an attempt

            // ---> Update Bullet Counter UI AFTER successful shot <---
            if (!unlimitedBulletsEnabled) {
                 const bulletCounterEl = DOMElements.bulletCounter;
                 if (bulletCounterEl) {
                      const remaining = Math.max(0, numberOfOptions - questionAttempts[currentQuestion]); // Ensure not negative
                      bulletCounterEl.innerHTML = `<i class="fas fa-crosshairs"></i> Bullets: ${remaining}/${numberOfOptions}`;
                      if (remaining <= 0) {
                           bulletCounterEl.style.color = 'var(--danger)'; // Indicate zero
                      }
                 }
            }
            // ---> END UI UPDATE <---


            
            const shooterRect = DOMElements.shooter.getBoundingClientRect();
            const gameAreaRect = DOMElements.gameArea.getBoundingClientRect();

            // Clone the template bullet
            const newBulletElement = DOMElements.bulletTemplate.cloneNode(true);
            newBulletElement.style.display = 'block'; // Make it visible
            newBulletElement.removeAttribute('id'); // Avoid duplicate IDs

            // Calculate initial position - get dimensions robustly
            // Use computedStyle as fallback if offsetWidth/Height isn't available immediately
            const computedStyle = getComputedStyle(DOMElements.bulletTemplate);
            const bulletWidth = newBulletElement.offsetWidth || parseInt(computedStyle.width) || 8; // Default width 8px
            const bulletHeight = newBulletElement.offsetHeight || parseInt(computedStyle.height) || 18; // Default height 18px

            const startX = shooterRect.left - gameAreaRect.left + (shooterRect.width / 2) - (bulletWidth / 2);
            const startY = shooterRect.top - gameAreaRect.top - bulletHeight; // Start just above shooter

            // Position the new bullet element
            newBulletElement.style.left = `${startX}px`;
            newBulletElement.style.top = `${startY}px`;

            // Add the element to the game area
            DOMElements.gameArea.appendChild(newBulletElement);

            // Add the new bullet's state to our tracking array
            activeBullets.push({
                element: newBulletElement,
                x: startX,
                y: startY,
                width: bulletWidth,  // Store dimensions for collision detection
                height: bulletHeight
            });
        }

        // --- NEW FUNCTION for Out of Bullets Popup ---
        function showOutOfBulletsPopup() {
            // Prevent triggering if already failed or paused in a way we shouldn't interrupt
            if (questionFailed || !gameActive) return;

            questionFailed = true; // Mark question as failed state to prevent other actions
            pauseTimer();        // Pause the timer
            stopGameLoop();      // Stop target/bullet movement

            // Record failure immediately before showing popup
            // Important: Record with the number of attempts used (which is numberOfOptions)
            userData.attempts.push({
                question: currentQuestion + 1,
                colA: quizData[currentQuestion].colA,
                correctAnswer: currentCorrectAnswer,
                time: Math.round((Date.now() - questionStartTime) / 1000), // Time until failure trigger
                points: 0,
                attempts: numberOfOptions, // They used all allowed attempts
                status: 'failed'
            });

            Swal.fire({
                title: 'Out of Bullets!',
                text: `You used all ${numberOfOptions} bullet${numberOfOptions === 1 ? '' : 's'} without hitting the correct target.`,
                icon: 'warning',
                showCancelButton: true,
                confirmButtonText: 'Next Question (0 points)', // Confirm moves on
                cancelButtonText: 'Try Again',               // Cancel retries
                confirmButtonColor: primaryColor,
                cancelButtonColor: textSecondary,
                allowOutsideClick: false, // Prevent closing by clicking outside
                allowEscapeKey: false,    // Prevent closing with Esc key
            }).then((result) => {
                // loadQuestion will reset questionFailed flag and restart necessary timers/loops
                if (result.isConfirmed) {
                    // User chose "Next Question"
                    console.log("User chose Next Question after running out of bullets.");
                    currentQuestion++; // Move to the next question index
                    loadQuestion();    // Load the next question
                } else if (result.dismiss === Swal.DismissReason.cancel) {
                    // User chose "Try Again"
                    console.log("User chose Try Again after running out of bullets.");

                     // Reset attempts counter *for this specific question* so they get full bullets again
                     questionAttempts[currentQuestion] = 0;

                     // Remove the 'failed' entry we just added for this attempt, as they are retrying
                     const lastFailedIndex = userData.attempts.map(a => a.question === (currentQuestion + 1) && a.status === 'failed').lastIndexOf(true);
                     if(lastFailedIndex > -1) {
                        userData.attempts.splice(lastFailedIndex, 1);
                        console.log("Removed preliminary failed attempt record for retry.");
                     } else {
                        console.warn("Could not find the preliminary failed attempt record to remove for retry.");
                     }

                    loadQuestion(); // Reload the *current* question
                }
            });
        }

        // --- Game Loop ---
        function startGameLoop() {
            if (gameLoopId) cancelAnimationFrame(gameLoopId); // Clear any existing loop
            gameLoopId = requestAnimationFrame(gameLoop);
        }
        function stopGameLoop() {
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = null;
            gameActive = false; // Explicitly stop game activity
            keysPressed = {}; // Clear keys when stopping loop
        }

        
        function gameLoop() {
            // --- Core Loop Condition Check ---
            // Stop processing if game isn't active, timer is paused, or the question has already failed
            if (!gameActive || timerPaused || questionFailed) {
                // Still request the next frame to keep checking the state, but do nothing else
                gameLoopId = requestAnimationFrame(gameLoop);
                return;
            }

            // --- Get Necessary Dimensions/Positions ---
            // Get these each frame as window/element sizes might change (though unlikely mid-game)
            const gameAreaRect = DOMElements.gameArea.getBoundingClientRect();
            const shooterRect = DOMElements.shooter.getBoundingClientRect(); // Current shooter position

            // --- 1. Update Shooter Position ---
            // Handles movement based on currently pressed keys ('ArrowLeft', 'ArrowRight', 'KeyA', 'KeyD')
            updateShooterPosition(); // Assumes this function exists and correctly updates shooterX and style.left

            // --- 2. Update Bullets & Check Collisions / Offscreen ---
            // Iterate backwards through active bullets for safe removal during loop
            for (let i = activeBullets.length - 1; i >= 0; i--) {
                let bullet = activeBullets[i];
                let bulletRemoved = false; // Flag to track removal in this iteration

                // Update bullet's vertical position
                bullet.y -= BULLET_SPEED; // Move bullet upwards
                bullet.element.style.top = `${bullet.y}px`;

                // Check if bullet is off-screen (above the game area)
                if (bullet.y < -bullet.height) { // Use stored bullet height
                    bullet.element.remove();      // Remove from DOM
                    activeBullets.splice(i, 1); // Remove from tracking array
                    bulletRemoved = true;         // Mark as removed
                    continue; // Skip collision checks for this removed bullet
                }

                // If bullet is still on screen, check for collisions with active targets
                if (!bulletRemoved) {
                    // Define the bullet's bounding box for collision detection
                    const bulletRect = {
                        left: bullet.x,
                        top: bullet.y,
                        right: bullet.x + bullet.width,
                        bottom: bullet.y + bullet.height
                    };

                    // Check against each active target
                    // Iterate backwards is safe for removal, though not strictly needed here as we break on hit
                    for (let j = activeTargets.length - 1; j >= 0; j--) {
                        let target = activeTargets[j];

                        // Skip targets that have already been hit in this question
                        if (target.hit) continue;

                        // Define the target's bounding box
                        const targetRect = {
                            left: target.x,
                            top: target.y,
                            right: target.x + target.width,
                            bottom: target.y + target.height
                        };

                        // Simple AABB (Axis-Aligned Bounding Box) collision check
                        if (bulletRect.left < targetRect.right &&
                            bulletRect.right > targetRect.left &&
                            bulletRect.top < targetRect.bottom &&
                            bulletRect.bottom > targetRect.top)
                        {
                            // --- Collision Detected! ---
                            bullet.element.remove();      // Remove the bullet from DOM
                            activeBullets.splice(i, 1); // Remove bullet from tracking array
                            bulletRemoved = true;         // Mark bullet as removed

                            target.hit = true; // Mark the target as hit (prevents multiple hits)

                            // Handle consequences of the hit (scoring, animation, next question)
                            handleBulletHit(target); // Assumes this function exists

                            // Since this bullet hit a target, break the inner target loop (j)
                            // and proceed to the next bullet (i) in the outer loop.
                            break;
                        }
                    } // End of target collision check loop (j)
                } // End of collision check block (if !bulletRemoved)
            } // End of activeBullets loop (i)


            // --- 3. Update Target Positions & Check Bounce / Failure (Target Reaching Bottom) ---
            let targetReachedBottom = false; // Reset flag for this frame check
            // Calculate shooter's top position relative to the game area for the failure check
            const shooterTopRelative = shooterRect.top - gameAreaRect.top;

            // Iterate through all active targets
            activeTargets.forEach(target => {
                // Skip targets that have already been hit
                if (target.hit) return;

                // Update target position based on its velocity
                target.x += target.vx;
                target.y += target.vy; // vy is the downward speed

                // Handle horizontal bouncing off the game area edges
                if (target.x <= 0 || (target.x + target.width) >= gameAreaRect.width) {
                    target.vx *= -1; // Reverse horizontal direction
                    // Clamp position to prevent sticking slightly outside bounds
                    target.x = Math.max(0, Math.min(target.x, gameAreaRect.width - target.width));
                }

                // Apply the updated position to the target's element style
                target.element.style.left = `${target.x}px`;
                target.element.style.top = `${target.y}px`;

                // Check for Failure: Target reaches near the shooter level
                // Check only if the question hasn't already failed from another cause
                 if (!questionFailed && (target.y + target.height) >= (shooterTopRelative - TARGET_FAILURE_PADDING)) {
                    targetReachedBottom = true; // Set flag if ANY unhit target reaches the line
                    // Optional: Visually indicate the failing target (e.g., change color)
                    // target.element.style.backgroundColor = 'orange';
                 }
            });

            // --- 4. Handle Failure State (Target Reaching Bottom) ---
            // This check is done *after* iterating through all targets for the frame
            if (targetReachedBottom) {
                 // Call the specific failure handler for this scenario
                 handleQuestionFailure("TargetReachedBottom"); // Pass reason for clarity/future use
                 // Note: The loop continues briefly, but game logic pauses via the questionFailed flag set inside handleQuestionFailure
            }

            // --- 5. Request Next Frame ---
            // Continue the loop only if the game is still considered active
            if (gameActive) { // Added check just to be safe, though top check should catch most exits
                 gameLoopId = requestAnimationFrame(gameLoop);
            } else {
                 console.log("Game loop stopping because gameActive is false."); // Debug log
                 stopGameLoop(); // Ensure cleanup if gameActive becomes false unexpectedly
            }
        }


        function handleBulletHit(target) {
            // No pausing timer or game loop needed for this approach

            if (target.word === currentCorrectAnswer) {
                // --- CORRECT HIT ---
                target.element.classList.add('target-hit-correct'); // Start animation immediately

                const timeTaken = Math.max(1, Math.round((Date.now() - questionStartTime) / 1000));
                const timeBasedPoints = calculatePoints(timeTaken); // Get time-based points

                // ---> START: Bonus Point Calculation <---
                const shotsFired = questionAttempts[currentQuestion] || 1; // Get shots for this question (default to 1 if somehow undefined)
                let bonusPoints = 0;
                if (shotsFired === 1) {
                    bonusPoints = 10;
                } else if (shotsFired === 2) {
                    bonusPoints = 5;
                } else if (shotsFired === 3) {
                    bonusPoints = 1;
                } // bonusPoints remains 0 for > 3 shots

                const totalPointsThisRound = timeBasedPoints + bonusPoints; // Combine points
                // ---> END: Bonus Point Calculation <---

                userData.totalPoints += totalPointsThisRound; // Add TOTAL points to overall score

                // Record attempt data (store TOTAL points and shots fired)
                userData.attempts.push({
                    question: currentQuestion + 1,
                    colA: quizData[currentQuestion].colA,
                    correctAnswer: currentCorrectAnswer,
                    time: timeTaken,
                    points: totalPointsThisRound, // Store the combined points
                    attempts: shotsFired,         // Store the actual attempts for this question
                    status: 'correct'
                });

                // Construct popup text showing the breakdown
                let popupText = `+${timeBasedPoints} (time)`;
                if (bonusPoints > 0) {
                    popupText += ` +${bonusPoints} (bonus)`;
                }
                popupText += ` = ${totalPointsThisRound} total!`;

                // Show a *non-blocking* toast immediately (with updated text)
                Swal.fire({
                    title: 'Correct!',
                    text: popupText, // Use the new text showing breakdown
                    icon: 'success',
                    toast: true, position: 'top-end', // Use 'top-end' or similar for less intrusion
                    showConfirmButton: false, timer: POPUP_TIMER_CORRECT_MS, timerProgressBar: true, // Assumes POPUP_TIMER_CORRECT_MS exists
                    // Prevent focus stealing which can interrupt gameplay
                    didOpen: (toast) => {
                         toast.addEventListener('mouseenter', Swal.stopTimer);
                         toast.addEventListener('mouseleave', Swal.resumeTimer);
                         // Try to prevent focus shift
                         const focusedElement = document.activeElement;
                         if (focusedElement && focusedElement !== document.body) {
                             setTimeout(() => focusedElement.focus(), 0);
                         }
                    }
                });

                // --- IMMEDIATE NEXT QUESTION --- (Remains the same)
                currentQuestion++;
                // Use requestAnimationFrame to ensure the animation *starts* before we potentially clear it
                requestAnimationFrame(() => {
                     // Optional small delay if transition feels TOO abrupt, but 0 is fine
                     setTimeout(() => {
                        loadQuestion(); // Load next question right away (Assumes loadQuestion exists)
                     }, 0); // 0ms delay - load ASAP after current frame renders
                });

            } else {
                // --- INCORRECT HIT --- (Remains unchanged from your previous version)
                target.element.classList.add('target-hit-incorrect'); // Start animation immediately

                // Show a non-blocking toast
                Swal.fire({
                   title: 'Incorrect!', icon: 'error',
                   toast: true, position: 'top-end',
                   showConfirmButton: false, timer: POPUP_TIMER_INCORRECT_MS, timerProgressBar: true, // Assumes POPUP_TIMER_INCORRECT_MS exists
                    // Prevent focus stealing
                    didOpen: (toast) => {
                         toast.addEventListener('mouseenter', Swal.stopTimer);
                         toast.addEventListener('mouseleave', Swal.resumeTimer);
                         const focusedElement = document.activeElement;
                         if (focusedElement && focusedElement !== document.body) {
                             setTimeout(() => focusedElement.focus(), 0);
                         }
                    }
                });

                // Remove the hit target *after* its animation completes
                // Use setTimeout matching the animation duration (0.5s = 500ms from your CSS)
                // Make sure this duration matches your .target-hit-incorrect animation duration
                const incorrectAnimationDuration = 500; // Adjust if your CSS animation time is different
                setTimeout(() => {
                    if (target.element && target.element.parentNode) { // Check if element still exists and is in DOM
                        target.element.remove();
                    }
                    // Remove from activeTargets array regardless, to prevent future checks on it
                    activeTargets = activeTargets.filter(t => t !== target);
                }, incorrectAnimationDuration);

                // --- DO NOT load next question here ---
                // --- DO NOT pause/resume timer --- The game continues immediately
            }
        }


                function handleQuestionFailure(reason = "TargetReachedBottom") { // Reason primarily for clarity now
                        // Prevent multiple failure popups/logic execution for the same question instance
                        if (questionFailed) {
                                console.log("handleQuestionFailure called but questionFailed is already true. Skipping.");
                                return;
                        }
                        questionFailed = true; // Set flag immediately to prevent race conditions/other actions

                        console.log(`Handling Question Failure. Reason: ${reason}`); // Debug log

                        pauseTimer();    // Pause the overall quiz timer
                        stopGameLoop();  // Stop target/bullet movement and further loop processing

                        // Record failure (0 points) - Ensure this runs only ONCE per trigger
                        // Record attempts made *up to this point* of failure
                        userData.attempts.push({
                                question: currentQuestion + 1,
                                colA: quizData[currentQuestion].colA,
                                correctAnswer: currentCorrectAnswer, // Store the correct answer
                                time: Math.round((Date.now() - questionStartTime) / 1000), // Time elapsed for this question
                                points: 0,
                                attempts: questionAttempts[currentQuestion], // Record attempts made *before* this failure
                                status: 'failed'
                        });
                        console.log("Recorded 'failed' status for question:", currentQuestion + 1); // Debug log

                        // --- Popup specific to "Target Reached Bottom" ---
                        let failureTitle = 'Target Reached Bottom!';
                        let failureText = "You didn't hit the correct target in time.";

                        Swal.fire({
                                title: failureTitle,
                                text: failureText,
                                icon: 'warning',
                                showCancelButton: true,
                                confirmButtonText: 'Next Question (0 points)', // Confirm moves on
                                cancelButtonText: 'Try Again',               // Cancel retries the current question
                                confirmButtonColor: primaryColor,            // Use defined theme color
                                cancelButtonColor: textSecondary,          // Use defined theme color
                                allowOutsideClick: false,                   // Prevent accidental dismissal
                                allowEscapeKey: false,                      // Prevent accidental dismissal
                        }).then((result) => {
                                // Note: loadQuestion() will reset the questionFailed flag to false
                                if (result.isConfirmed) {
                                        // User chose "Next Question"
                                        console.log("User chose Next Question after target reached bottom.");
                                        currentQuestion++; // Increment to the next question index
                                        loadQuestion();    // Load the next question (or results if finished)
                                } else if (result.dismiss === Swal.DismissReason.cancel) {
                                        // User chose "Try Again"
                                        console.log("User chose Try Again after target reached bottom.");

                                        // Reset attempts counter *for this specific question* so they can shoot again
                                        questionAttempts[currentQuestion] = 0;

                                        // Remove the 'failed' entry we just added from userData.attempts, as they are retrying
                                        // Search from the end to ensure the most recent 'failed' record for this question number is removed
                                        const lastFailedIndex = userData.attempts.map(a => a.question === (currentQuestion + 1) && a.status === 'failed').lastIndexOf(true);
                                        if(lastFailedIndex > -1) {
                                                userData.attempts.splice(lastFailedIndex, 1);
                                                console.log("Removed preliminary failed attempt record for retry.");
                                        } else {
                                                console.warn("Could not find the preliminary failed attempt record to remove for retry.");
                                        }

                                        loadQuestion(); // Reload the *current* question
                                }
                        });
                }


        // --- Timer Functions ---
        function startTimer() {
            clearInterval(timerInterval); elapsedTime = 0;
            DOMElements.timerDisplay.textContent = elapsedTime; timerPaused = false;
            userData.startTime = Date.now();
            timerInterval = setInterval(() => {
                if (!timerPaused && gameActive) { // Only advance timer if game is active and not paused
                    elapsedTime = Math.floor((Date.now() - userData.startTime) / 1000);
                    DOMElements.timerDisplay.textContent = elapsedTime;
                }
            }, 1000);
        }
        function pauseTimer() { timerPaused = true; }
        function resumeTimer() { timerPaused = false; }

        // --- Scoring ---
        function calculatePoints(seconds) {
             const brackets = [[5,10],[10,9],[15,8],[20,7],[25,6],[30,5],[40,4],[50,3],[60,2],[Infinity,1]];
            for (const [max, points] of brackets) { if (seconds <= max) return points; } return 0;
        }

        // --- Utility ---
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]];
            } return array;
        }

        // --- Results Display ---
        function showResults() {
            stopGameLoop(); // Ensure game loop is stopped
            clearInterval(timerInterval);
            // Explicitly hide the quiz screen to be absolutely sure
            DOMElements.quizScreen.style.display = 'none';
            showScreen('resultsScreen');

            const completionDate = new Date();
            const day = completionDate.getDate().toString().padStart(2, '0');
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = monthNames[completionDate.getMonth()];
            const year = completionDate.getFullYear();
            const hours = completionDate.getHours().toString().padStart(2, '0');
            const minutes = completionDate.getMinutes().toString().padStart(2, '0');
            const completionTimestamp = `${day} ${month} ${year}, ${hours}:${minutes}`;

            const correctCount = userData.attempts.filter(a => a.status === 'correct').length;
            const failedCount = userData.attempts.filter(a => a.status === 'failed').length;
             // Skipped = total questions - (correct + failed)
            const skippedCount = quizData.length - userData.attempts.length;


            // Update Summary
            DOMElements.resultSummary.innerHTML = `
                <div class="result-stat"><i class="fas fa-user"></i><span><strong>Name:</strong> ${userData.name || 'N/A'}</span></div>
                <div class="result-stat"><i class="fas fa-calendar-check"></i><span><strong>Completed:</strong> ${completionTimestamp}</span></div>
                <div class="result-stat"><i class="fas fa-book"></i><span><strong>Quiz Title:</strong> ${window.quizTitle || 'N/A'}</span></div>
                <div class="result-stat"><i class="fas fa-trophy"></i><span><strong>Total Score:</strong> ${userData.totalPoints} points</span></div>
                <div class="result-stat"><i class="fas fa-check-circle" style="color: var(--success);"></i><span><strong>Correct:</strong> ${correctCount} / ${quizData.length}</span></div>
                <div class="result-stat"><i class="fas fa-times-circle" style="color: var(--danger);"></i><span><strong>Failed/Skipped:</strong> ${failedCount + skippedCount} / ${quizData.length}</span></div>
            `;

            // Update Table
            const table = DOMElements.resultsTable;
            let tableHTML = `
                <thead><tr><th>#</th><th>Word</th><th>Correct Match</th><th>Status</th><th>Time (s)</th><th>Attempts</th><th>Points</th></tr></thead>
                <tbody>`;

             for (let i = 0; i < quizData.length; i++) {
                 const questionNum = i + 1;
                 const attemptData = userData.attempts.find(a => a.question === questionNum);
                 const questionInfo = quizData[i];

                 if (attemptData) { // Question was attempted (correct or failed)
                     let statusClass = '';
                     let statusText = '';
                     if (attemptData.status === 'correct') {
                         statusClass = 'correct'; statusText = 'Correct';
                     } else if (attemptData.status === 'failed') {
                         statusClass = 'failed'; statusText = 'Failed';
                     }
                     tableHTML += `
                        <tr>
                            <td>${questionNum}</td><td>${questionInfo.colA}</td><td>${questionInfo.colB}</td>
                            <td class="${statusClass}">${statusText}</td>
                            <td>${attemptData.time}</td><td>${attemptData.attempts}</td><td>${attemptData.points}</td>
                        </tr>`;
                 } else { // Question was skipped (game ended before reaching it)
                      tableHTML += `
                        <tr>
                            <td>${questionNum}</td><td>${questionInfo.colA}</td><td>${questionInfo.colB}</td>
                            <td class="incorrect"><em>Skipped</em></td><td>-</td><td>0</td><td>0</td>
                        </tr>`;
                 }
             }
            tableHTML += `</tbody>`;
            table.innerHTML = tableHTML;
        }

        // --- Results Actions ---
        function screenshotResults() {
            Swal.fire({ title: 'Generating Screenshot', text: 'Please wait...', allowOutsideClick: false, showConfirmButton: false, willOpen: () => Swal.showLoading() });
            const resultsElement = DOMElements.resultsScreen.querySelector('.card');
            html2canvas(resultsElement, { scale: 2, useCORS: true }).then(canvas => {
                Swal.close(); const link = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                link.download = `LanguageShooter-Results-${userData.name || 'User'}-${timestamp}.png`;
                link.href = canvas.toDataURL("image/png"); link.click();
                Swal.fire('Success!', 'Results screenshot downloaded.', 'success', { confirmButtonColor: primaryColor });
            }).catch(err => {
                Swal.close(); console.error("Screenshot error:", err);
                Swal.fire('Error', 'Could not generate screenshot.', 'error', { confirmButtonColor: primaryColor });
            });
        }

        function reviewQuestions() {
             Swal.fire({
                title: 'Play Again?', text: 'Restart the same quiz? Previous results will be cleared.',
                icon: 'question', showCancelButton: true, confirmButtonText: 'Yes, Restart', cancelButtonText: 'No, Go Home',
                confirmButtonColor: primaryColor, cancelButtonColor: textSecondary, reverseButtons: true
            }).then((result) => {
                if (result.isConfirmed) {
                     if (!currentSheetId) { Swal.fire("Error", "Cannot determine quiz to restart.", "error"); goHome(); return; }
                    // Reset state and reload data for the *same* quiz, then go to name screen
                    startQuizFlow(currentSheetId);
                } else if (result.dismiss === Swal.DismissReason.cancel) {
                    goHome();
                }
            });
        }

    </script>
</body>
</html>
