<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Language Shooter</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- Removed SortableJS CSS -->
    <style>
        /* Base Styles (Adapted from provided CSS) */
        :root {
            --primary: #1a73e8; /* Modern blue color (Google style) */
            --primary-hover: #0b5fdb; /* Darker shade for hover */
            --secondary: #e5e7eb;

            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --warning: #f59e0b; /* Yellow */
            --light: #f9fafb;

            /* target and shooter color */
            --accent: #8b5cf6; /* target color */
            --target-text-color: white; /* target text color */
            --dark: #111827; /* shooter color */
            --shooter-text-color: white; /* shooter text color */
            --success: #10b981; /* Green */
             --danger: #ef4444; /* Red */

            
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --radius: 0.5rem;
            --transition: all 0.3s ease;

            /* Font for targets/shooter */
             --word-box-font-family: KaiTi, 'Kaiti SC', DFKai-SB, BiauKai, 'Microsoft YaHei', 'SimHei', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
             --word-box-font-size: 1.6rem; /* Slightly larger for game elements */

            /* Game Speeds */
            --shooter-speed: 15px; /* Pixels moved per arrow key press */
            --bullet-speed: 15px; /* Pixels moved per frame */
            --target-downward-speed: 0.5px; /* Pixels moved down per frame */
            --target-horizontal-speed-max: 1.5px; /* Max absolute horizontal speed */
        }

        /* Rotating icon animation */
        .rotate-icon { display: inline-block; animation: spin 3s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Text fill effect */
        .fill-text { display: inline-block; background: linear-gradient(90deg, var(--primary), var(--accent)); background-size: 200% 100%; -webkit-background-clip: text; color: transparent; animation: fillText 5s ease infinite; }
        @keyframes fillText { from { background-position: -100% 0; } to { background-position: 0 0; } }

        /* Typography */
        body { font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; margin: 0; padding: 0; background-color: #f3f4f6; color: var(--text-primary); line-height: 1.5; }
        h1, h2, h3, h4, h5, h6 { font-weight: 600; margin-top: 0; color: var(--dark); }
        h1 { font-size: 2rem; margin-bottom: 1.5rem; }
        h2 { font-size: 1.5rem; margin-bottom: 1rem; }

        /* Layout */
        .app-container { max-width: 1000px; margin: 0 auto; padding: 1rem; min-height: 100vh; display: flex; flex-direction: column; }
        .app-header { text-align: center; padding: 1rem 0; border-bottom: 1px solid var(--secondary); margin-bottom: 2rem; }
        .app-footer { margin-top: auto; text-align: center; padding: 1rem 0; font-size: 0.875rem; color: var(--text-secondary); border-top: 1px solid var(--secondary); }
        .app-footer a { color: #6b7280; text-decoration: none; }

        /* Cards and Screens */
        .screen { display: none; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease; transform: translateY(10px); }
        .screen.active { display: block; opacity: 1; transform: translateY(0); }
        .card { background: white; border-radius: var(--radius); box-shadow: var(--shadow); padding: 2rem; margin-bottom: 1.5rem; transition: var(--transition); }
        .card-header { margin-bottom: 1.5rem; border-bottom: 1px solid var(--secondary); padding-bottom: 1rem; }
        .card-title { font-size: 1.25rem; margin: 0; }
        .card-body { margin-bottom: 1.5rem; }
        .card-footer { border-top: 1px solid var(--secondary); padding-top: 1rem; display: flex; justify-content: center; flex-wrap: wrap; gap: 0.5rem; }

        /* Form Elements */
        .form-group { margin-bottom: 1.5rem; }
        .form-control { display: block; width: 100%; padding: 0.75rem; font-size: 1rem; border: 1px solid var(--secondary); border-radius: var(--radius); transition: var(--transition); box-sizing: border-box; }
        .form-control:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.2); }
        #quizId, #userName { width: 100%; margin: 0; padding: 0.75rem; }
        .center-button { text-align: center; }

        /* Buttons */
        .btn { display: inline-block; font-weight: 500; text-align: center; vertical-align: middle; user-select: none; padding: 0.75rem 1.5rem; font-size: 1rem; line-height: 1.5; border-radius: var(--radius); transition: var(--transition); cursor: pointer; border: none; }
        .btn-primary { background-color: var(--primary); color: white; }
        .btn-primary:hover { background-color: var(--primary-hover); }
        .btn-secondary { background-color: var(--secondary); color: var(--text-primary); }
        .btn-secondary:hover { background-color: #d1d5db; }

        /* Quiz Screen Specific Styles */
       #quizScreen {
            position: relative;
            overflow: hidden; /* Contain absolute elements */
            /* min-height: 70vh; */ /* Line removed */
            flex-grow: 1; /* Allow quiz screen to expand */ /* <-- ADD THIS LINE */
            background: linear-gradient(180deg, #e0f7fa 0%, #b3e5fc 100%); /* Light blue gradient bg */
            display: flex; /* Add this to make gameArea sizing easier if needed */
            flex-direction: column; /* Stack header/progress/gameArea vertically */
        }
        
        .quiz-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem; padding: 0.5rem; background: rgba(255, 255, 255, 0.7); border-radius: var(--radius); position: relative; z-index: 20; /* Above game area */ }
        .timer-container, .quiz-title-display, .question-counter { display: flex; align-items: center; gap: 0.5rem; font-weight: 600; color: var(--text-secondary); padding: 0.5rem 1rem; background: var(--light); border-radius: var(--radius); }
        .timer-container i { color: var(--primary); }
        .timer-value { color: var(--text-primary); }
        .quiz-instructions { margin: 0.5rem 0 1rem 0; padding: 0.75rem; background-color: rgba(26, 115, 232, 0.1); border-left: 4px solid var(--primary); border-radius: 0 var(--radius) var(--radius) 0; font-size: 0.875rem; color: var(--text-secondary); position: relative; z-index: 20; /* Above game area */}
        .progress-container { width: 100%; height: 8px; background-color: var(--secondary); border-radius: 4px; overflow: hidden; margin-bottom: 1rem; position: relative; z-index: 20; /* Above game area */}
        .progress-bar { height: 100%; background-color: var(--primary); transition: width 0.3s ease; }

        #gameArea {
            position: relative; /* Back to relative positioning */ /* <-- CHANGED */
            /* top: 0; left: 0; right: 0; bottom: 0; */ /* Removed */
            flex-grow: 1; /* Make game area fill remaining vertical space */ /* <-- ADDED */
            border: none;
            border-radius: var(--radius);
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><path fill="%23d1d5db" fill-opacity="0.1" d="M10 10 H90 V90 H10Z M0 0 H100 V100 H0Z" /></svg>');
            overflow: hidden;
            /* z-index no longer strictly needed unless overlap issues arise */
            /* You might want margin-top if needed: */
            /* margin-top: 0.5rem;  */
        }

        #shooter {
            position: absolute;
            bottom: 10px;
            left: 50%; /* Initial position set by JS */
            /* transform: translateX(-50%); */ /* Handled by JS positioning */
            padding: 0.8rem 1.8rem; /* Slightly adjusted */
            background-color: var(--dark);
            color: var(--shooter-text-color);
            border-radius: var(--radius);
            font-family: var(--word-box-font-family);
            font-size: var(--word-box-font-size);
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 10;
            border-top: 3px solid var(--primary);
            white-space: nowrap; /* Prevent wrapping */
            transition: left 0.1s linear; /* Smooth movement */
        }

        .target {
            position: absolute; /* Positioned within gameArea */
            padding: 0.6rem 1.2rem;
            background-color: var(--accent);
            color: var(--target-text-color);
            border-radius: 50px; /* Pill shape */
            font-family: var(--word-box-font-family);
            font-size: calc(var(--word-box-font-size) * 0.9); /* Slightly smaller than shooter */
            /* cursor: pointer; */ /* No longer clickable */
            transition: transform 0.2s ease, background-color 0.2s ease; /* Keep for animations */
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 5;
            user-select: none; /* Prevent text selection */
            white-space: nowrap; /* Prevent wrapping */
        }

        /* Removed hover effect as targets are not directly interactive */
        /* .target:hover { transform: scale(1.1); background-color: var(--primary-hover); } */

        /* Target Animations */
        @keyframes targetHitCorrect {
            0% { transform: scale(1) rotate(0deg); opacity: 1; background-color: var(--success); }
            50% { transform: scale(1.3) rotate(15deg); opacity: 0.5; }
            100% { transform: scale(0.5) rotate(-15deg); opacity: 0; background-color: var(--success); }
        }
        .target-hit-correct {
            animation: targetHitCorrect 0.5s ease-out forwards;
            pointer-events: none; /* Prevent hitting again during animation */
        }

        @keyframes targetHitIncorrect { /* Simple shake and fade */
             0% { transform: translateX(0); opacity: 1; background-color: var(--danger); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-8px); }
            80% { transform: translateX(8px); }
            100% { transform: translateX(0); opacity: 0; background-color: var(--danger); }
        }
        .target-hit-incorrect {
            animation: targetHitIncorrect 0.5s linear forwards;
             pointer-events: none; /* Prevent hitting again during animation */
        }

        #bullet {
            position: absolute;
            width: 8px; /* Slimmer */
            height: 18px; /* Longer */
            background: linear-gradient(to top, var(--warning), gold); /* Gradient */
            border-radius: 4px 4px 0 0; /* Rounded top */
            box-shadow: 0 0 6px yellow;
            z-index: 9;
            /* transition: top 0.016s linear, left 0.016s linear; */ /* Movement handled by JS animation frame */
            pointer-events: none; /* Don't block clicks */
            display: none; /* Hidden initially */
        }


        /* Results Screen (Mostly reused styles) */
        .result-summary { padding: 1.5rem; background-color: #f3f4f6; border-radius: var(--radius); margin-bottom: 1.5rem; }
        .result-stat { display: flex; align-items: center; margin-bottom: 0.75rem; }
        .result-stat i { margin-right: 0.75rem; color: var(--primary); width: 24px; text-align: center; }
        .results-table-container { overflow-x: auto; margin-bottom: 1.5rem; }
        .results-table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
        .results-table th, .results-table td { padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--secondary); }
        .results-table th { background-color: #f9fafb; font-weight: 600; color: var(--text-secondary); }
        .results-table tr:hover td { background-color: #f3f4f6; }
        .results-table td.correct { color: var(--success); font-weight: bold; }
        .results-table td.incorrect { color: var(--danger); font-style: italic; }
        .results-table td.failed { color: var(--danger); font-style: italic; } /* For failed questions */

        /* Divider */
        .divider { display: flex; align-items: center; margin: 1.5rem 0; color: var(--text-secondary); font-size: 0.875rem; }
        .divider::before, .divider::after { content: ""; flex: 1; border-bottom: 1px solid var(--secondary); }
        .divider::before { margin-right: 1rem; }
        .divider::after { margin-left: 1rem; }

        /* Google Sheet Dropdown Styling */
        #quizSelect { /* Style reused */ width: 100%; padding: 0.75rem; font-size: 1rem; border: 1px solid var(--secondary); border-radius: var(--radius); transition: var(--transition); background-color: white; color: var(--text-primary); appearance: none; -webkit-appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%236b7280'%3E%3Cpath d='M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 0.75rem top 50%; background-size: 1.25rem; }
        #quizSelect:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.2); }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .card { padding: 1.5rem; }
            .quiz-header { flex-direction: column; align-items: flex-start; width: 100%; }
            .timer-container, .quiz-title-display, .question-counter { width: 100%; box-sizing: border-box; margin: 0.25rem 0; padding: 0.5rem; font-size: 0.875rem; justify-content: center; }
            /* Game area height is determined by absolute positioning now */
            #shooter { padding: 0.7rem 1.5rem; font-size: calc(var(--word-box-font-size) * 0.9); bottom: 5px;}
            .target { padding: 0.5rem 1rem; font-size: calc(var(--word-box-font-size) * 0.8); }
            .results-table th, .results-table td { padding: 0.5rem; font-size: 0.75rem; }
        }
        @media (max-width: 480px) {
            h1 { font-size: 1.8rem; }
            .card-footer { justify-content: center; }
            .btn { width: 100%; margin-bottom: 0.5rem; }
            /* Game area height is determined by absolute positioning now */
             #shooter { padding: 0.6rem 1.2rem; font-size: calc(var(--word-box-font-size) * 0.8); bottom: 2px;}
            .target { padding: 0.4rem 0.8rem; font-size: calc(var(--word-box-font-size) * 0.7); }
            .quiz-title-display { font-size: 0.8rem; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
             <h1><i class="fas fa-crosshairs rotate-icon"></i>
                <span class="fill-text">Language Shooter</span>
             </h1>
        </header>

        <!-- Landing Screen -->
        <div id="landingScreen" class="screen active">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Welcome to Language Shooter</h2>
                    <p>Take aim and match the words!</p>
                </div>
                <div class="card-body">
                    <!-- Quiz Selection -->
                    <div class="form-group">
                        <label for="quizSelect" class="form-label">Built-in Games:</label>
                        <select id="quizSelect" class="form-control"></select> <!-- Options populated by JS -->
                    </div>
                    <div class="center-button">
                        <button onclick="startSelectedQuiz()" class="btn btn-primary" disable> <!-- Initially disabled -->
                            <i class="fas fa-play-circle"></i> Start Built-in Game
                        </button>
                    </div>
                    <div class="divider">OR</div>

                    <div class="form-group">
                        <label for="quizId" class="form-label">Have a custom game?</label>
                        <p class="form-text" style="margin-top: 0.25rem; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.875rem;">
                            <i class="fas fa-info-circle"></i> Game ID is provided by your teacher
                        </p>
                        <input type="text" id="quizId" placeholder="Enter Game ID" class="form-control">
                    </div>
                </div>
                 <div class="center-button">
                    <button onclick="startCustomQuiz()" class="btn btn-secondary">
                        <i class="fas fa-file-import"></i> Start Custom Game
                    </button>
                </div>
            </div>
        </div>

        <!-- Name Screen -->
        <div id="nameScreen" class="screen">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Ready Player?</h2>
                </div>
                <div class="card-body">
                    <div class="form-group">
                        <label for="userName" class="form-label">Enter Your Name</label>
                        <input type="text" id="userName" required class="form-control" placeholder="Your Name">
                    </div>
                </div>
                <div class="card-footer">
                    <button onclick="startQuiz()" class="btn btn-primary">
                        <i class="fas fa-gamepad"></i> Start Game
                    </button>
                    <button onclick="goHome()" class="btn btn-secondary">
                        <i class="fas fa-home"></i> Back to Home
                    </button>
                </div>
            </div>
        </div>

        <!-- Quiz Screen -->
        <div id="quizScreen" class="screen">
             <!-- Header elements (now above game area) -->
            <div class="quiz-header">
                <div class="timer-container">
                    <i class="fas fa-clock"></i> Time: <span id="timer" class="timer-value">0</span>s
                </div>
                 <div id="quizTitleDisplay" class="quiz-title-display">
                     <!-- Quiz title will be shown here -->
                 </div>
                <div class="question-counter" id="questionNumber"></div>
            </div>
            <div id="progressContainer" class="progress-container">
                <div id="progressBar" class="progress-bar" style="width: 0%"></div>
            </div>
             <div class="quiz-instructions">
                <i class="fas fa-arrows-alt-h"></i> Move: Left/Right Arrows    <i class="fas fa-keyboard"></i> Fire: Spacebar
            </div>

            <!-- Game Area -->
            <div id="gameArea">
                 <!-- Shooter -->
                <div id="shooter">
                    <!-- Current Column A word here -->
                </div>

                <!-- Bullet Element (initially hidden) -->
                <div id="bullet"></div>

                <!-- Targets will be added here by JS -->
            </div>
        </div>

        <!-- Results Screen -->
        <div id="resultsScreen" class="screen">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Game Results</h2>
                </div>
                <div class="card-body">
                    <div class="result-summary" id="resultSummary">
                        <!-- Results summary will be inserted here -->
                    </div>

                    <div class="results-table-container">
                        <table id="resultsTable" class="results-table">
                            <!-- Results table will be inserted here -->
                        </table>
                    </div>
                </div>
                <div class="card-footer">
                    <button onclick="screenshotResults()" class="btn btn-secondary">
                        <i class="fas fa-camera"></i> Screenshot Results
                    </button>
                    <button onclick="reviewQuestions()" class="btn btn-primary">
                        <i class="fas fa-redo"></i> Play Again
                    </button>
                     <button onclick="goHome()" class="btn btn-secondary">
                        <i class="fas fa-home"></i> Back to Home
                    </button>
                </div>
            </div>
        </div>

        <footer class="app-footer">
            <div id="visitor-counter">
               Welcome! You're visitor #<span id="pageviews">Loading...</span>
            </div>
            <p><a href="https://linsnotes.com">linsnotes.com</a></p>
        </footer>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.4/xlsx.full.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script data-goatcounter="https://linsnotes.goatcounter.com/count" async src="https://gc.zgo.at/count.js"></script>

    <script>
        // --- Global State ---
        let currentQuestion = 0;
        let quizData = []; // Array of { colA: "word1", colB: "match1" }
        let allColBTargets = []; // Array of all unique Column B words for target generation
        let userData = { name: '', startTime: 0, attempts: [], totalPoints: 0 }; // Attempts: { question: num, colA: str, correctAnswer: str, time: sec, points: num, attempts: num, status: 'correct' | 'failed' | 'skipped' }
        let timerInterval;
        let timerPaused = false;
        let elapsedTime = 0;
        let questionStartTime = 0; // Track start time for each question
        let questionAttempts = {}; // Tracks shots fired per question index { index: count }
        let questionFailed = false; // Flag if the current question failed due to target reaching bottom

        // --- Constants & Config ---
        const QUIZ_LIST_SHEET_ID = '1b_yzMM-qy_g9Sa-kO5mPtAL67neZdaIW_QIQcfFHaNg'; // Replace if needed
        const SHOOTER_MOVE_SPEED = 15; // Pixels per keydown event
        const BULLET_SPEED = 12; // Pixels per frame
        const TARGET_DOWNWARD_SPEED = 0.5; // Pixels per frame
        const TARGET_HORIZONTAL_SPEED_MAX = 1.0; // Max horizontal pixels per frame
        const TARGET_SPAWN_Y_OFFSET = -50; // Start targets slightly above the screen
        const TARGET_FAILURE_PADDING = 20; // How close target needs to get to shooter top to fail
        let numberOfOptions = 4; // Default target count

        // --- NEW CONSTANTS FOR POPUP TIMERS ---
        const POPUP_TIMER_CORRECT_MS = 1200;    // Duration for the "Correct!" popup (milliseconds)
        const POPUP_TIMER_INCORRECT_MS = 1200;  // Duration for the "Incorrect!" popup (milliseconds)

        // --- Game State ---
        let gameLoopId = null;
        let shooterX = 0; // Current horizontal position (pixels from left)
        let activeBullets = []; // Array of { element: DOMEl, x: num, y: num, width: num, height: num } // ADD THIS LINE
        let activeTargets = []; // Array of { element: DOMEl, x: num, y: num, vx: num, vy: num, word: str, hit: bool }
        let keysPressed = {}; // Track pressed keys for smoother movement
        let gameActive = false; // Is the game loop running?

        // --- DOM Cache ---
        const DOMElements = {
            landingScreen: document.getElementById('landingScreen'),
            nameScreen: document.getElementById('nameScreen'),
            quizScreen: document.getElementById('quizScreen'),
            resultsScreen: document.getElementById('resultsScreen'),
            quizSelect: document.getElementById('quizSelect'),
            quizIdInput: document.getElementById('quizId'),
            userNameInput: document.getElementById('userName'),
            timerDisplay: document.getElementById('timer'),
            quizTitleDisplay: document.getElementById('quizTitleDisplay'),
            questionNumberDisplay: document.getElementById('questionNumber'),
            progressBar: document.getElementById('progressBar'),
            gameArea: document.getElementById('gameArea'),
            shooter: document.getElementById('shooter'),
            bulletTemplate: document.getElementById('bullet'), 
            resultSummary: document.getElementById('resultSummary'),
            resultsTable: document.getElementById('resultsTable'),
            startBuiltInButton: document.querySelector('button[onclick="startSelectedQuiz()"]'),
            appHeader: document.querySelector('.app-header'),
            appFooter: document.querySelector('.app-footer')
        };

        // --- Computed Styles Cache ---
        const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary').trim();
        const textSecondary = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadQuizTitlesAndIds();
            // Add keyboard listeners globally, but only act when gameActive
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            // Cache bullet element
            bulletState.element = DOMElements.bullet;

            // pageviews counter
            const pv = document.getElementById('pageviews');

            if (pv !== null) {
                const uri = location.pathname.replace(/\/$/, '');
                const url = `https://linsnotes.goatcounter.com/counter/${encodeURIComponent(uri)}.json`;

                fetch(url)
                    .then((response) => response.json())
                    .then((data) => {
                        const count = data.count.replace(/\s/g, '');
                        pv.innerText = new Intl.NumberFormat().format(count);
                    })
                    .catch((error) => {
                        pv.innerText = '1';
                    });
            }
        });

        // --- Screen Management ---
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const targetScreen = DOMElements[screenId];
            if (targetScreen) {
                targetScreen.classList.add('active');
            } else {
                console.error(`Screen with ID ${screenId} not found.`);
                DOMElements.landingScreen.classList.add('active'); // Fallback
            }
            const showHeaderFooter = (screenId !== 'quizScreen');
            DOMElements.appHeader.style.display = showHeaderFooter ? 'block' : 'none';
            DOMElements.appFooter.style.display = showHeaderFooter ? 'block' : 'none';
            gameActive = (screenId === 'quizScreen'); // Control game loop activity
        }

        function goHome() {
            stopGameLoop();
            resetQuizState();
            DOMElements.quizIdInput.value = '';
            DOMElements.quizSelect.selectedIndex = 0;
            DOMElements.startBuiltInButton.disabled = true;
            DOMElements.appHeader.style.display = 'block';
            DOMElements.appFooter.style.display = 'block';
            showScreen('landingScreen');
        }

        // --- Data Loading ---
        async function loadSheetData(sheetId) {
                try {
                        const url = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
                        const response = await fetch(url);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        const csv = await response.text();
                        const workbook = XLSX.read(csv, { type: 'string' });
                        const sheetName = workbook.SheetNames[0];
                        if (!sheetName) throw new Error('No sheet found.');

                        // header: 1 reads rows as arrays, 0-indexed
                        const rows = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });

                        // Existing title read
                        window.quizTitle = rows?.[0]?.[0]?.trim() || `Quiz (${sheetId.substring(0, 6)}...)`;

                        // ---> Read number of options from C1 <---
                        const optionsCellValue = rows?.[0]?.[2]; // Cell C1 is at index 2 in the first row (index 0)
                        let parsedOptions = parseInt(optionsCellValue, 10); // Attempt to parse as integer

                        if (isNaN(parsedOptions) || parsedOptions < 1) {
                                // If C1 is empty, not a number, or less than 1, use the default
                                numberOfOptions = 4;
                                console.log("Cell C1 is empty or invalid. Defaulting to 4 target options.");
                        } else {
                                // Otherwise, use the valid number from C1
                                numberOfOptions = parsedOptions;
                                console.log(`Number of target options read from C1: ${numberOfOptions}`);
                        }
                        // Ensure numberOfOptions is at least 1 (to show the correct answer)
                        if (numberOfOptions < 1) {
                            console.warn("numberOfOptions was less than 1, setting to 1.");
                            numberOfOptions = 1;
                        }
                        // ---> read from C1 <---

                        // Existing data processing
                        const data = rows.slice(1) // Start from the second row for actual quiz data
                                .map(row => ({
                                        colA: row[0] ? String(row[0]).trim() : null,
                                        colB: row[1] ? String(row[1]).trim() : null
                                        // Column C (index 2) is ignored here for quiz data itself
                                }))
                                .filter(item => item.colA && item.colB);

                        if (data.length === 0) {
                                console.warn('Sheet has no valid data rows.'); return null;
                        }
                        // Store all unique Column B values for targets (remains the same)
                        allColBTargets = [...new Set(data.map(item => item.colB))];
                        return data;
                } catch (error) {
                        console.error('Error loading sheet data:', error);
                        Swal.fire('Error Loading Game', `Could not load game data [${sheetId}]. Check ID/sharing. Details: ${error.message}`, 'error', { confirmButtonColor: primaryColor });
                        return null;
                }
        }

        async function loadQuizTitlesAndIds() {
             if (!QUIZ_LIST_SHEET_ID || QUIZ_LIST_SHEET_ID === 'YOUR_QUIZ_LIST_SHEET_ID_HERE') { // Check if ID is set
                console.warn("Quiz/Game List Sheet ID not set. Disabling built-in quiz/game option.");
                DOMElements.quizSelect.innerHTML = '<option value="" disabled selected>Built-in Games Unavailable</option>';
                DOMElements.quizSelect.disabled = true;
                DOMElements.startBuiltInButton.disabled = true;
                return;
             }
            try {
                const url = `https://docs.google.com/spreadsheets/d/${QUIZ_LIST_SHEET_ID}/export?format=csv&gid=0`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const csv = await response.text();
                const workbook = XLSX.read(csv, { type: 'string' });
                const sheetName = workbook.SheetNames[0];
                if (!sheetName) throw new Error('No sheet found for quiz list.');
                const rows = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });

                quizTitlesAndIds = rows.slice(1)
                    .map(row => ({ title: row[0]?.trim(), id: row[1]?.trim() }))
                    .filter(quiz => quiz.title && quiz.id);
                populateQuizSelect();
            } catch (error) {
                console.error('Error loading game titles:', error);
                 Swal.fire('Error Loading Game List', `Could not load built-in Games. Details: ${error.message}`, 'error', { confirmButtonColor: primaryColor });
                DOMElements.quizSelect.innerHTML = '<option value="" disabled selected>Error Loading Games</option>';
                DOMElements.quizSelect.disabled = true;
                DOMElements.startBuiltInButton.disabled = true;
            }
        }

        function populateQuizSelect() {
            const select = DOMElements.quizSelect;
            select.innerHTML = '';
            if (quizTitlesAndIds.length === 0) {
                select.innerHTML = '<option value="" disabled selected>No Built-in Games Found</option>';
                select.disabled = true;
                DOMElements.startBuiltInButton.disabled = true; return;
            }
            const defaultOption = document.createElement('option');
            defaultOption.value = ""; defaultOption.textContent = "-- Select a Built-in Game --";
            defaultOption.disabled = true; defaultOption.selected = true; select.appendChild(defaultOption);
            quizTitlesAndIds.forEach(quiz => {
                const option = document.createElement('option'); option.value = quiz.id; option.textContent = quiz.title; select.appendChild(option);
            });
            select.disabled = false; DOMElements.startBuiltInButton.disabled = true;
            select.addEventListener('change', function() {
                currentSheetId = this.value; DOMElements.quizIdInput.value = '';
                DOMElements.startBuiltInButton.disabled = !this.value;
            });
        }

        // --- Quiz Flow Control ---
        function startSelectedQuiz() {
            // Check if a built-in quiz is selected
            if (!currentSheetId) {
                // Use Swal.fire for the popup, matching the puzzle app style
                Swal.fire({
                    title: 'No Game Selected', // Changed title slightly for Shooter context
                    text: 'Please select a game from the dropdown list.', // Matched puzzle app text
                    icon: 'warning', // Matched puzzle app icon
                    confirmButtonColor: primaryColor // Use the cached primary color variable
                });
                return; // Stop the function here
            }
            // If a sheet ID is selected, proceed
            startQuizFlow(currentSheetId);
        }

        async function startCustomQuiz() {
            const sheetId = DOMElements.quizIdInput.value.trim();
            if (!sheetId) { Swal.fire('Missing Input', 'Please enter a Custom Quiz Google Sheet ID.', 'warning', { confirmButtonColor: primaryColor }); return; }
            currentSheetId = sheetId; startQuizFlow(sheetId);
        }
        async function startQuizFlow(sheetId) {
            Swal.fire({ title: 'Loading Game', text: 'Please wait...', allowOutsideClick: false, showConfirmButton: false, willOpen: () => Swal.showLoading() });
            const data = await loadSheetData(sheetId);
            if (!data || data.length === 0) {
                Swal.close(); if (data !== null) { Swal.fire('Empty or Invalid Quiz', 'No valid questions found.', 'warning', { confirmButtonColor: primaryColor }); } return;
            }
            quizData = data;
            resetQuizState(false); // Reset state but keep name/sheetId if already entered
            Swal.close();
            showScreen('nameScreen');
        }

        function resetQuizState(fullReset = true) {
            stopGameLoop(); // Ensure loop is stopped
            clearInterval(timerInterval);
            currentQuestion = 0;
            quizData = fullReset ? [] : quizData;
            allColBTargets = fullReset ? [] : allColBTargets;
            userData.startTime = 0;
            userData.attempts = [];
            userData.totalPoints = 0;
            timerInterval = null;
            timerPaused = false;
            elapsedTime = 0;
            questionStartTime = 0;
            questionAttempts = {};
            questionFailed = false;
            currentCorrectAnswer = '';
            activeTargets = []; // Clear active targets array
            keysPressed = {}; // Clear pressed keys
             if (fullReset) {
                 userData.name = ''; currentSheetId = ''; window.quizTitle = '';
             }
             // Clear UI elements
             DOMElements.resultSummary.innerHTML = '';
             DOMElements.resultsTable.innerHTML = '';
             DOMElements.gameArea.innerHTML = ''; // Clear targets from DOM
             DOMElements.shooter.textContent = '';
             DOMElements.progressBar.style.width = '0%';
             DOMElements.timerDisplay.textContent = '0';
             DOMElements.questionNumberDisplay.textContent = '';
             DOMElements.quizTitleDisplay.textContent = '';
             // Re-add shooter and bullet structure to gameArea
             DOMElements.gameArea.appendChild(DOMElements.shooter);
             DOMElements.gameArea.appendChild(DOMElements.bullet);
             bulletState.element = DOMElements.bullet; // Re-cache bullet element
             bulletState.active = false;
             bulletState.element.style.display = 'none';

        }

        function startQuiz() {
            userData.name = DOMElements.userNameInput.value.trim();
            if (!userData.name) { Swal.fire('Missing Input', 'Please enter your name.', 'warning', { confirmButtonColor: primaryColor }); return; }
            quizData.forEach((_, idx) => { questionAttempts[idx] = 0; });
            showScreen('quizScreen');
            DOMElements.quizTitleDisplay.textContent = window.quizTitle || 'Language Shooter';
            positionShooter(); // Set initial shooter position
            loadQuestion(); // Will also start the game loop
            startTimer(); // Start the overall quiz timer
        }

        // --- Game Logic ---
        function positionShooter() {
            const gameAreaWidth = DOMElements.gameArea.clientWidth;
            const shooterWidth = DOMElements.shooter.offsetWidth;
            shooterX = (gameAreaWidth - shooterWidth) / 2; // Center initial position
            DOMElements.shooter.style.left = `${shooterX}px`;
        }

        // --- Updated loadQuestion function ---
        function loadQuestion() {
             // Stop previous loop if any - necessary to reset target/bullet state for the new question
             if (gameLoopId) {
                 cancelAnimationFrame(gameLoopId);
                 gameLoopId = null; // Explicitly clear the ID
             }

             gameActive = true; // Ensure game is active for this screen
             questionFailed = false; // Reset failure flag for the new question

             // Check if quiz is finished
             if (currentQuestion >= quizData.length) {
                 showResults(); // Assumes showResults exists
                 return;
             }

            // --- Clear old game elements FIRST ---
            clearGameElements(); // This will remove any remaining targets/bullet from the previous question

            // Get data for the current question
            const questionData = quizData[currentQuestion];
            currentCorrectAnswer = questionData.colB;

            // Update UI elements
            DOMElements.shooter.textContent = questionData.colA; // Assumes DOMElements cache exists

            // Reposition shooter after text content potentially changes its width
            // Use requestAnimationFrame to ensure accurate measurement after render
             requestAnimationFrame(() => {
                 positionShooter(); // Assumes positionShooter exists
             });

            // Update progress bar and question counter
            const progress = ((currentQuestion + 1) / quizData.length) * 100;
            DOMElements.progressBar.style.width = `${progress}%`; // Assumes DOMElements cache exists
            DOMElements.questionNumberDisplay.textContent = `Question ${currentQuestion + 1} of ${quizData.length}`; // Assumes DOMElements cache exists

            // Prepare and display NEW targets for the current question
            spawnTargets(); // Assumes spawnTargets exists

            // Reset timer for the question & ensure the overall timer is running
            questionStartTime = Date.now();
            resumeTimer(); // Assumes resumeTimer exists (ensures timer is not paused)

            // Start the game loop for this new question
            startGameLoop(); // Assumes startGameLoop exists
        }

        function clearGameElements() {
                // Remove target DOM elements (existing code)
                activeTargets.forEach(t => {
                        if (t.element && t.element.parentNode) { // Check if element exists and is in DOM
                                t.element.remove();
                        }
                });
                activeTargets = [];

                // ---> ADD THIS: Remove active bullet DOM elements <---
                activeBullets.forEach(b => {
                        if (b.element && b.element.parentNode) { // Check if element exists and is in DOM
                                b.element.remove();
                        }
                });
                activeBullets = []; // Clear the tracking array
                // ---> END ADD <---

                // Hide bullet TEMPLATE (redundant if CSS handles it, but safe)
                // if (DOMElements.bulletTemplate) {
                //     DOMElements.bulletTemplate.style.display = 'none';
                // }
        }

        // --- UPDATED resetQuizState Function ---
        function resetQuizState(fullReset = true) {
                stopGameLoop(); // Ensure loop is stopped
                clearInterval(timerInterval);
                currentQuestion = 0;
                quizData = fullReset ? [] : quizData;
                allColBTargets = fullReset ? [] : allColBTargets;
                userData.startTime = 0;
                userData.attempts = [];
                userData.totalPoints = 0;
                timerInterval = null;
                timerPaused = false;
                elapsedTime = 0;
                questionStartTime = 0;
                questionAttempts = {};
                questionFailed = false;
                currentCorrectAnswer = '';
                activeTargets = []; // Clear active targets array

                // ---> ADD THIS: Clear active bullets (DOM and Array) <---
                activeBullets.forEach(b => {
                        if (b.element && b.element.parentNode) {
                                b.element.remove();
                        }
                });
                activeBullets = [];
                // ---> END ADD <---

                keysPressed = {}; // Clear pressed keys

                if (fullReset) {
                        userData.name = ''; currentSheetId = ''; window.quizTitle = '';
                }

                // Clear UI elements
                DOMElements.resultSummary.innerHTML = '';
                DOMElements.resultsTable.innerHTML = '';

                // Clear dynamically added children from gameArea (targets, bullets)
                // Keep shooter and bullet template
                Array.from(DOMElements.gameArea.children).forEach(child => {
                        // Check against the cached elements
                        if (child !== DOMElements.shooter && child !== DOMElements.bulletTemplate) {
                                child.remove();
                        }
                });

                // Reset other UI specific to the quiz screen
                DOMElements.shooter.textContent = '';
                DOMElements.progressBar.style.width = '0%';
                DOMElements.timerDisplay.textContent = '0';
                DOMElements.questionNumberDisplay.textContent = '';
                DOMElements.quizTitleDisplay.textContent = '';

                // Ensure the bullet template remains hidden (CSS should primarily handle this)
                if (DOMElements.bulletTemplate) {
                        DOMElements.bulletTemplate.style.display = 'none';
                }
        }

        function spawnTargets() {
                const gameArea = DOMElements.gameArea;
                const areaWidth = gameArea.clientWidth;
                const areaHeight = gameArea.clientHeight; // Use for Y spawning

                // Clear any remnants from previous question (though clearGameElements should handle this)
                activeTargets.forEach(t => t.element.remove());
                activeTargets = [];

                // ---> START TARGET SELECTION LOGIC <---

                const correctAnswer = currentCorrectAnswer; // Get the correct answer for the current question

                // Filter out the correct answer to get only potential incorrect options
                let incorrectOptions = allColBTargets.filter(target => target !== correctAnswer);

                // Shuffle the available incorrect options
                incorrectOptions = shuffle(incorrectOptions);

                // Determine how many incorrect options we need (total options - 1 for the correct one)
                // Ensure it's not negative if numberOfOptions is 1
                const numberOfIncorrectNeeded = Math.max(0, numberOfOptions - 1);

                // Select the required number of incorrect options
                // .slice will handle cases where fewer incorrect options are available than needed
                const selectedIncorrect = incorrectOptions.slice(0, numberOfIncorrectNeeded);

                // Combine the correct answer with the selected incorrect ones
                // Handle the case where the correct answer might be the ONLY option available in the sheet
                let finalTargetsToShow = [];
                if (allColBTargets.includes(correctAnswer)) {
                        finalTargetsToShow = [correctAnswer, ...selectedIncorrect];
                } else {
                        // Fallback: if the correct answer isn't even in the list (shouldn't happen with current logic, but safe)
                        finalTargetsToShow = selectedIncorrect.slice(0, numberOfOptions); // Just show incorrect ones up to the limit
                        console.warn("Correct answer was not found in allColBTargets list.");
                }

                // Ensure the total number of targets doesn't exceed numberOfOptions
                // This mainly handles edge cases like numberOfOptions=1 or very few unique Col B values.
                finalTargetsToShow = finalTargetsToShow.slice(0, numberOfOptions);

                // Shuffle the final list so the correct answer's position is random
                finalTargetsToShow = shuffle(finalTargetsToShow);

                console.log(`Spawning ${finalTargetsToShow.length} targets (requested ${numberOfOptions}):`, finalTargetsToShow); // Optional: for debugging

                // Now, create target elements ONLY for the words in finalTargetsToShow
                finalTargetsToShow.forEach(targetWord => {
                        const targetElement = document.createElement('div');
                        targetElement.className = 'target';
                        targetElement.textContent = targetWord;
                        targetElement.dataset.word = targetWord; // Store word

                        gameArea.appendChild(targetElement); // Add to DOM first to measure width

                        const targetWidth = targetElement.offsetWidth;
                        const targetHeight = targetElement.offsetHeight; // Store height

                        // Initial Position (Random X, slightly above screen)
                        // Ensure targets don't overlap too much horizontally initially if many targets
                        let x;
                        let attempts = 0;
                        const maxAttempts = 10; // Prevent infinite loop if space is tight
                        let placed = false;

                        do {
                            x = Math.random() * (areaWidth - targetWidth);
                            placed = true;
                            // Basic check against already placed targets in this spawn cycle
                            // Note: This isn't perfect collision avoidance but helps initial spread
                            activeTargets.forEach(existingTarget => {
                                if (Math.abs(x - existingTarget.x) < (targetWidth + existingTarget.width) / 2) { // Approximate horizontal overlap check
                                    placed = false;
                                }
                            });
                            attempts++;
                        } while (!placed && attempts < maxAttempts);

                        // If we failed to find a non-overlapping spot after attempts, just use the last random X
                        if (!placed) {
                            x = Math.random() * (areaWidth - targetWidth);
                        }

                        // Spread out initial Y based on height and randomness
                        const y = TARGET_SPAWN_Y_OFFSET - (Math.random() * areaHeight * 0.3) - (targetHeight * activeTargets.length * 0.1);

                        // Initial Velocity (Random horizontal, constant downward)
                        const vx = (Math.random() * 2 - 1) * TARGET_HORIZONTAL_SPEED_MAX; // -Max to +Max
                        const vy = TARGET_DOWNWARD_SPEED;

                        targetElement.style.left = `${x}px`;
                        targetElement.style.top = `${y}px`;

                        activeTargets.push({
                                element: targetElement,
                                x: x, y: y,
                                vx: vx, vy: vy,
                                word: targetWord,
                                width: targetWidth, // Store dimensions for collision
                                height: targetHeight,
                                hit: false // Flag to prevent multiple hits/checks
                        });
                });

                // ---> END TARGET SELECTION LOGIC <---
        }

        // --- Input Handling ---
        function handleKeyDown(event) {
            if (!gameActive) return; // Only handle keys during the quiz screen
            keysPressed[event.code] = true;

            // Handle firing immediately on Space press down
            if (event.code === 'Space' && !bulletState.active) {
                fireBullet();
                event.preventDefault(); // Prevent scrolling page down
            }
        }
        function handleKeyUp(event) {
            if (!gameActive) return;
            keysPressed[event.code] = false;
        }

        function updateShooterPosition() {
            const gameAreaWidth = DOMElements.gameArea.clientWidth;
            const shooterWidth = DOMElements.shooter.offsetWidth;
            const moveAmount = SHOOTER_MOVE_SPEED; // Adjust speed here

            if (keysPressed['ArrowLeft'] || keysPressed['KeyA']) {
                shooterX -= moveAmount;
            }
            if (keysPressed['ArrowRight'] || keysPressed['KeyD']) {
                shooterX += moveAmount;
            }

            // Keep shooter within bounds
            shooterX = Math.max(0, Math.min(shooterX, gameAreaWidth - shooterWidth));

            DOMElements.shooter.style.left = `${shooterX}px`;
        }

        function fireBullet() {
            // REMOVED: if (bulletState.active) return; // No longer limiting to one bullet

            questionAttempts[currentQuestion]++; // Count every shot as an attempt

            const shooterRect = DOMElements.shooter.getBoundingClientRect();
            const gameAreaRect = DOMElements.gameArea.getBoundingClientRect();

            // Clone the template bullet
            const newBulletElement = DOMElements.bulletTemplate.cloneNode(true);
            newBulletElement.style.display = 'block'; // Make it visible
            newBulletElement.removeAttribute('id'); // Avoid duplicate IDs

            // Calculate initial position - get dimensions robustly
            // Use computedStyle as fallback if offsetWidth/Height isn't available immediately
            const computedStyle = getComputedStyle(DOMElements.bulletTemplate);
            const bulletWidth = newBulletElement.offsetWidth || parseInt(computedStyle.width) || 8; // Default width 8px
            const bulletHeight = newBulletElement.offsetHeight || parseInt(computedStyle.height) || 18; // Default height 18px

            const startX = shooterRect.left - gameAreaRect.left + (shooterRect.width / 2) - (bulletWidth / 2);
            const startY = shooterRect.top - gameAreaRect.top - bulletHeight; // Start just above shooter

            // Position the new bullet element
            newBulletElement.style.left = `${startX}px`;
            newBulletElement.style.top = `${startY}px`;

            // Add the element to the game area
            DOMElements.gameArea.appendChild(newBulletElement);

            // Add the new bullet's state to our tracking array
            activeBullets.push({
                element: newBulletElement,
                x: startX,
                y: startY,
                width: bulletWidth,  // Store dimensions for collision detection
                height: bulletHeight
            });
        }


        // --- Game Loop ---
        function startGameLoop() {
            if (gameLoopId) cancelAnimationFrame(gameLoopId); // Clear any existing loop
            gameLoopId = requestAnimationFrame(gameLoop);
        }
        function stopGameLoop() {
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = null;
            gameActive = false; // Explicitly stop game activity
            keysPressed = {}; // Clear keys when stopping loop
        }


        function gameLoop() {
                if (!gameActive || timerPaused || questionFailed) { // Stop loop if paused, failed, or not on quiz screen
                        gameLoopId = requestAnimationFrame(gameLoop); // Keep checking state
                        return;
                }

                const gameAreaRect = DOMElements.gameArea.getBoundingClientRect();
                const shooterRect = DOMElements.shooter.getBoundingClientRect(); // Get current shooter pos

                // 1. Update Shooter Position (based on keysPressed)
                updateShooterPosition(); // Assumes this function exists and works

                // 2. Update ALL Bullets & Check Collisions / Offscreen
                // Iterate backwards through the activeBullets array to safely remove elements while looping
                for (let i = activeBullets.length - 1; i >= 0; i--) {
                        let bullet = activeBullets[i];
                        let bulletRemoved = false; // Flag to track if this bullet is removed in this iteration

                        // Update bullet position
                        bullet.y -= BULLET_SPEED;
                        bullet.element.style.top = `${bullet.y}px`;

                        // Check if bullet went off-screen (top)
                        if (bullet.y < -bullet.height) { // Use stored height
                                bullet.element.remove(); // Remove from DOM
                                activeBullets.splice(i, 1); // Remove from array
                                bulletRemoved = true; // Mark as removed
                                continue; // Go to the next bullet in the loop (this one is gone)
                        }

                        // If bullet still exists (wasn't removed for being off-screen), check for collisions with targets
                        if (!bulletRemoved) {
                                const bulletRect = {
                                        left: bullet.x,
                                        top: bullet.y,
                                        right: bullet.x + bullet.width, // Use stored width
                                        bottom: bullet.y + bullet.height // Use stored height
                                };

                                // Iterate through active targets to check for collision
                                for (let j = activeTargets.length - 1; j >= 0; j--) { // Can iterate targets normally or backward
                                        let target = activeTargets[j];

                                        if (target.hit) continue; // Skip targets that have already been hit

                                        const targetRect = {
                                                left: target.x,
                                                top: target.y,
                                                right: target.x + target.width,
                                                bottom: target.y + target.height
                                        };

                                        // Simple AABB (Axis-Aligned Bounding Box) collision check
                                        if (bulletRect.left < targetRect.right &&
                                            bulletRect.right > targetRect.left &&
                                            bulletRect.top < targetRect.bottom &&
                                            bulletRect.bottom > targetRect.top)
                                        {
                                                // Collision detected!
                                                bullet.element.remove(); // Remove THE COLLIDING BULLET from DOM
                                                activeBullets.splice(i, 1); // Remove THE COLLIDING BULLET from array
                                                bulletRemoved = true; // Mark bullet as removed

                                                target.hit = true; // Mark THE TARGET as hit (prevents multiple hits on same target)
                                                handleBulletHit(target); // Call the function to handle consequences (score, animation, etc.)

                                                // Since this bullet hit a target, it's gone. Stop checking this bullet against other targets.
                                                break; // Exit the inner target loop (j) and move to the next bullet (i)
                                        }
                                } // End of target collision check loop (j)
                        } // End of collision check block (if !bulletRemoved)
                } // End of activeBullets loop (i)


                // 3. Update Target Positions & Check Bounce / Failure (This part remains the same as your original code)
                let targetReachedBottom = false;
                const shooterTopRelative = shooterRect.top - gameAreaRect.top; // Shooter Y relative to gameArea

                activeTargets.forEach(target => {
                        if (target.hit) return; // Skip already hit targets

                        // Update position
                        target.x += target.vx;
                        target.y += target.vy;

                        // Horizontal bounce
                        if (target.x <= 0 || (target.x + target.width) >= gameAreaRect.width) {
                                target.vx *= -1; // Reverse horizontal direction
                                target.x = Math.max(0, Math.min(target.x, gameAreaRect.width - target.width)); // Clamp position
                        }

                        // Apply new position
                        target.element.style.left = `${target.x}px`;
                        target.element.style.top = `${target.y}px`;

                        // Check failure condition (target reaches shooter level)
                        if (!questionFailed && (target.y + target.height) >= (shooterTopRelative - TARGET_FAILURE_PADDING)) {
                                targetReachedBottom = true;
                                // Mark the target visually maybe? (Optional)
                                // target.element.style.backgroundColor = 'orange';
                        }
                });

                // 4. Handle Failure State (outside target loop to process only once)
                if (targetReachedBottom) {
                        handleQuestionFailure(); // Assumes this function exists and works
                        // Loop continues briefly to allow popup, but game logic pauses via questionFailed flag
                }

                // 5. Request Next Frame (Remains the same)
                gameLoopId = requestAnimationFrame(gameLoop);
        }


        function handleBulletHit(target) {
            // No pausing timer or game loop needed for this approach

            if (target.word === currentCorrectAnswer) {
                // --- CORRECT HIT ---
                target.element.classList.add('target-hit-correct'); // Start animation immediately

                const timeTaken = Math.max(1, Math.round((Date.now() - questionStartTime) / 1000));
                const timeBasedPoints = calculatePoints(timeTaken); // Get time-based points

                // ---> START: Bonus Point Calculation <---
                const shotsFired = questionAttempts[currentQuestion] || 1; // Get shots for this question (default to 1 if somehow undefined)
                let bonusPoints = 0;
                if (shotsFired === 1) {
                    bonusPoints = 10;
                } else if (shotsFired === 2) {
                    bonusPoints = 5;
                } else if (shotsFired === 3) {
                    bonusPoints = 1;
                } // bonusPoints remains 0 for > 3 shots

                const totalPointsThisRound = timeBasedPoints + bonusPoints; // Combine points
                // ---> END: Bonus Point Calculation <---

                userData.totalPoints += totalPointsThisRound; // Add TOTAL points to overall score

                // Record attempt data (store TOTAL points and shots fired)
                userData.attempts.push({
                    question: currentQuestion + 1,
                    colA: quizData[currentQuestion].colA,
                    correctAnswer: currentCorrectAnswer,
                    time: timeTaken,
                    points: totalPointsThisRound, // Store the combined points
                    attempts: shotsFired,         // Store the actual attempts for this question
                    status: 'correct'
                });

                // Construct popup text showing the breakdown
                let popupText = `+${timeBasedPoints} (time)`;
                if (bonusPoints > 0) {
                    popupText += ` +${bonusPoints} (bonus)`;
                }
                popupText += ` = ${totalPointsThisRound} total!`;

                // Show a *non-blocking* toast immediately (with updated text)
                Swal.fire({
                    title: 'Correct!',
                    text: popupText, // Use the new text showing breakdown
                    icon: 'success',
                    toast: true, position: 'top-end', // Use 'top-end' or similar for less intrusion
                    showConfirmButton: false, timer: POPUP_TIMER_CORRECT_MS, timerProgressBar: true, // Assumes POPUP_TIMER_CORRECT_MS exists
                    // Prevent focus stealing which can interrupt gameplay
                    didOpen: (toast) => {
                         toast.addEventListener('mouseenter', Swal.stopTimer);
                         toast.addEventListener('mouseleave', Swal.resumeTimer);
                         // Try to prevent focus shift
                         const focusedElement = document.activeElement;
                         if (focusedElement && focusedElement !== document.body) {
                             setTimeout(() => focusedElement.focus(), 0);
                         }
                    }
                });

                // --- IMMEDIATE NEXT QUESTION --- (Remains the same)
                currentQuestion++;
                // Use requestAnimationFrame to ensure the animation *starts* before we potentially clear it
                requestAnimationFrame(() => {
                     // Optional small delay if transition feels TOO abrupt, but 0 is fine
                     setTimeout(() => {
                        loadQuestion(); // Load next question right away (Assumes loadQuestion exists)
                     }, 0); // 0ms delay - load ASAP after current frame renders
                });

            } else {
                // --- INCORRECT HIT --- (Remains unchanged from your previous version)
                target.element.classList.add('target-hit-incorrect'); // Start animation immediately

                // Show a non-blocking toast
                Swal.fire({
                   title: 'Incorrect!', icon: 'error',
                   toast: true, position: 'top-end',
                   showConfirmButton: false, timer: POPUP_TIMER_INCORRECT_MS, timerProgressBar: true, // Assumes POPUP_TIMER_INCORRECT_MS exists
                    // Prevent focus stealing
                    didOpen: (toast) => {
                         toast.addEventListener('mouseenter', Swal.stopTimer);
                         toast.addEventListener('mouseleave', Swal.resumeTimer);
                         const focusedElement = document.activeElement;
                         if (focusedElement && focusedElement !== document.body) {
                             setTimeout(() => focusedElement.focus(), 0);
                         }
                    }
                });

                // Remove the hit target *after* its animation completes
                // Use setTimeout matching the animation duration (0.5s = 500ms from your CSS)
                // Make sure this duration matches your .target-hit-incorrect animation duration
                const incorrectAnimationDuration = 500; // Adjust if your CSS animation time is different
                setTimeout(() => {
                    if (target.element && target.element.parentNode) { // Check if element still exists and is in DOM
                        target.element.remove();
                    }
                    // Remove from activeTargets array regardless, to prevent future checks on it
                    activeTargets = activeTargets.filter(t => t !== target);
                }, incorrectAnimationDuration);

                // --- DO NOT load next question here ---
                // --- DO NOT pause/resume timer --- The game continues immediately
            }
        }

        function handleQuestionFailure() {
            questionFailed = true; // Set flag to stop game logic in loop
            pauseTimer();
            stopGameLoop(); // Stop updates but keep screen visible

             // Record failure (0 points)
             userData.attempts.push({
                 question: currentQuestion + 1,
                 colA: quizData[currentQuestion].colA,
                 correctAnswer: currentCorrectAnswer, // Store what it should have been
                 time: Math.round((Date.now() - questionStartTime) / 1000), // Time until failure
                 points: 0,
                 attempts: questionAttempts[currentQuestion],
                 status: 'failed' // Mark as failed
             });

            Swal.fire({
                title: 'Target Reached Bottom!',
                text: "You didn't hit the correct target in time.",
                icon: 'warning',
                showCancelButton: true,
                confirmButtonText: 'Continue (0 points)',
                cancelButtonText: 'Try Again',
                confirmButtonColor: primaryColor,
                cancelButtonColor: textSecondary,
                allowOutsideClick: false,
                allowEscapeKey: false,
            }).then((result) => {
                if (result.isConfirmed) {
                    // Continue: Move to next question
                    currentQuestion++;
                    loadQuestion(); // Will reset flags and restart loop
                } else if (result.dismiss === Swal.DismissReason.cancel) {
                    // Try Again: Reload the same question
                     // Reset attempts counter *for this specific question* if retrying
                     questionAttempts[currentQuestion] = 0;
                     // Find and remove the 'failed' entry from userData.attempts
                     const failedAttemptIndex = userData.attempts.findIndex(a => a.question === (currentQuestion + 1) && a.status === 'failed');
                     if (failedAttemptIndex > -1) {
                         userData.attempts.splice(failedAttemptIndex, 1);
                     }
                    loadQuestion(); // Reload current question (will reset flags and restart loop)
                }
            });
        }


        // --- Timer Functions ---
        function startTimer() {
            clearInterval(timerInterval); elapsedTime = 0;
            DOMElements.timerDisplay.textContent = elapsedTime; timerPaused = false;
            userData.startTime = Date.now();
            timerInterval = setInterval(() => {
                if (!timerPaused && gameActive) { // Only advance timer if game is active and not paused
                    elapsedTime = Math.floor((Date.now() - userData.startTime) / 1000);
                    DOMElements.timerDisplay.textContent = elapsedTime;
                }
            }, 1000);
        }
        function pauseTimer() { timerPaused = true; }
        function resumeTimer() { timerPaused = false; }

        // --- Scoring ---
        function calculatePoints(seconds) {
             const brackets = [[5,10],[10,9],[15,8],[20,7],[25,6],[30,5],[40,4],[50,3],[60,2],[Infinity,1]];
            for (const [max, points] of brackets) { if (seconds <= max) return points; } return 0;
        }

        // --- Utility ---
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]];
            } return array;
        }

        // --- Results Display ---
        function showResults() {
            stopGameLoop(); // Ensure game loop is stopped
            clearInterval(timerInterval);
            // Explicitly hide the quiz screen to be absolutely sure
            DOMElements.quizScreen.style.display = 'none';
            showScreen('resultsScreen');

            const completionDate = new Date();
            const day = completionDate.getDate().toString().padStart(2, '0');
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = monthNames[completionDate.getMonth()];
            const year = completionDate.getFullYear();
            const hours = completionDate.getHours().toString().padStart(2, '0');
            const minutes = completionDate.getMinutes().toString().padStart(2, '0');
            const completionTimestamp = `${day} ${month} ${year}, ${hours}:${minutes}`;

            const correctCount = userData.attempts.filter(a => a.status === 'correct').length;
            const failedCount = userData.attempts.filter(a => a.status === 'failed').length;
             // Skipped = total questions - (correct + failed)
            const skippedCount = quizData.length - userData.attempts.length;


            // Update Summary
            DOMElements.resultSummary.innerHTML = `
                <div class="result-stat"><i class="fas fa-user"></i><span><strong>Name:</strong> ${userData.name || 'N/A'}</span></div>
                <div class="result-stat"><i class="fas fa-calendar-check"></i><span><strong>Completed:</strong> ${completionTimestamp}</span></div>
                <div class="result-stat"><i class="fas fa-book"></i><span><strong>Quiz Title:</strong> ${window.quizTitle || 'N/A'}</span></div>
                <div class="result-stat"><i class="fas fa-trophy"></i><span><strong>Total Score:</strong> ${userData.totalPoints} points</span></div>
                <div class="result-stat"><i class="fas fa-check-circle" style="color: var(--success);"></i><span><strong>Correct:</strong> ${correctCount} / ${quizData.length}</span></div>
                <div class="result-stat"><i class="fas fa-times-circle" style="color: var(--danger);"></i><span><strong>Failed/Skipped:</strong> ${failedCount + skippedCount} / ${quizData.length}</span></div>
            `;

            // Update Table
            const table = DOMElements.resultsTable;
            let tableHTML = `
                <thead><tr><th>#</th><th>Word</th><th>Correct Match</th><th>Status</th><th>Time (s)</th><th>Attempts</th><th>Points</th></tr></thead>
                <tbody>`;

             for (let i = 0; i < quizData.length; i++) {
                 const questionNum = i + 1;
                 const attemptData = userData.attempts.find(a => a.question === questionNum);
                 const questionInfo = quizData[i];

                 if (attemptData) { // Question was attempted (correct or failed)
                     let statusClass = '';
                     let statusText = '';
                     if (attemptData.status === 'correct') {
                         statusClass = 'correct'; statusText = 'Correct';
                     } else if (attemptData.status === 'failed') {
                         statusClass = 'failed'; statusText = 'Failed';
                     }
                     tableHTML += `
                        <tr>
                            <td>${questionNum}</td><td>${questionInfo.colA}</td><td>${questionInfo.colB}</td>
                            <td class="${statusClass}">${statusText}</td>
                            <td>${attemptData.time}</td><td>${attemptData.attempts}</td><td>${attemptData.points}</td>
                        </tr>`;
                 } else { // Question was skipped (game ended before reaching it)
                      tableHTML += `
                        <tr>
                            <td>${questionNum}</td><td>${questionInfo.colA}</td><td>${questionInfo.colB}</td>
                            <td class="incorrect"><em>Skipped</em></td><td>-</td><td>0</td><td>0</td>
                        </tr>`;
                 }
             }
            tableHTML += `</tbody>`;
            table.innerHTML = tableHTML;
        }

        // --- Results Actions ---
        function screenshotResults() {
            Swal.fire({ title: 'Generating Screenshot', text: 'Please wait...', allowOutsideClick: false, showConfirmButton: false, willOpen: () => Swal.showLoading() });
            const resultsElement = DOMElements.resultsScreen.querySelector('.card');
            html2canvas(resultsElement, { scale: 2, useCORS: true }).then(canvas => {
                Swal.close(); const link = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                link.download = `LanguageShooter-Results-${userData.name || 'User'}-${timestamp}.png`;
                link.href = canvas.toDataURL("image/png"); link.click();
                Swal.fire('Success!', 'Results screenshot downloaded.', 'success', { confirmButtonColor: primaryColor });
            }).catch(err => {
                Swal.close(); console.error("Screenshot error:", err);
                Swal.fire('Error', 'Could not generate screenshot.', 'error', { confirmButtonColor: primaryColor });
            });
        }

        function reviewQuestions() {
             Swal.fire({
                title: 'Play Again?', text: 'Restart the same quiz? Previous results will be cleared.',
                icon: 'question', showCancelButton: true, confirmButtonText: 'Yes, Restart', cancelButtonText: 'No, Go Home',
                confirmButtonColor: primaryColor, cancelButtonColor: textSecondary, reverseButtons: true
            }).then((result) => {
                if (result.isConfirmed) {
                     if (!currentSheetId) { Swal.fire("Error", "Cannot determine quiz to restart.", "error"); goHome(); return; }
                    // Reset state and reload data for the *same* quiz, then go to name screen
                    startQuizFlow(currentSheetId);
                } else if (result.dismiss === Swal.DismissReason.cancel) {
                    goHome();
                }
            });
        }

    </script>
</body>
</html>
